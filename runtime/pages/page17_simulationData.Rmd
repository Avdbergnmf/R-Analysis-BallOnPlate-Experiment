### Plot Options
```{r}
# Participant and trial selection
selectizeInput("sim_participant", "Participant",
  choices = participants, selected = participants[1], multiple = FALSE
)
selectizeInput("sim_trialNum", "Trial Number",
  choices = allTrials, selected = allTrials[3], multiple = FALSE
)


# Variable selection for time series
selectizeInput("sim_vars", "Time-series variables",
  choices = NULL, multiple = TRUE
)

# Downsampling
numericInput("sim_downsampling", "Downsample factor",
  value = 1, min = 1, step = 1
)

# Risk predictions toggle
checkboxInput("enable_risk_predictions", "Enable Risk Predictions",
  value = FALSE, width = "100%"
)

# Direct model prediction toggle (for dashboard testing)
checkboxInput("allow_direct_model", "Allow Direct Model Prediction",
  value = FALSE, width = "100%"
)

# Tau parameter for risk predictions
numericInput("risk_tau", "Risk Prediction Time Horizon (seconds)",
  value = 0.0, min = 0, max = 5, step = 0.1, width = "100%"
)

# Sampling frequency for model training
numericInput("sampling_freq", "Sampling Frequency for Training (Hz)",
  value = 20, min = 1, max = 200, step = 1, width = "100%"
)

# Risk model management
selectizeInput("risk_model_file", "Risk Model File",
  choices = NULL, selected = NULL, multiple = FALSE
)

actionButton("load_risk_model", "Load Selected Model",
  class = "btn-success", style = "margin-top: 5px;"
)

actionButton("train_risk_model", "Train New Model",
  class = "btn-primary", style = "margin-top: 5px;"
)

# Hazard samples management
actionButton("update_hazard_cache", "Update Cache",
  class = "btn-info", style = "margin-top: 5px;"
)

actionButton("perform_risk_analysis", "Perform Risk Analysis",
  class = "btn-success", style = "margin-top: 5px;"
)

# Simulation data caching
actionButton("simUpdateData", "Update Simulation Data",
  class = "btn-primary", style = "margin-top: 10px;"
)

textOutput("risk_model_status")
```

Column
--------------------------------------------

### Simulation Data Availability
```{r}
textOutput("sim_data_status")
```

### Time Series Plot {data-height=600}
Shows selected variables over time.
```{r}
plotlyOutput("sim_tsPlot")
```

```{r, context="server"}
# Set up caching system for simulation data
page_logger <- create_module_logger("PAGE17-SIMULATION")

# Use the same cache manager as Page 5 (histograms) to share data
# Check if the cache manager already exists from Page 5
if (exists("cache_managers") && "simulation" %in% names(cache_managers)) {
  # Use existing cache manager from Page 5
  sim_cache_manager <- cache_managers[["simulation"]]
  page_logger("DEBUG", "Using existing simulation cache manager from Page 5")
} else {
  # Create new cache manager if Page 5 hasn't been loaded yet
  sim_cache_manager <- create_shiny_cache_manager("simulation", use_parallel = TRUE)
  page_logger("DEBUG", "Created new simulation cache manager for Page 17")
}

# Always create our own reactive data system for Page 17 to ensure proper connection
sim_cached_data <- create_shiny_cached_data_reactive(
  cache_manager = sim_cache_manager,
  data_type = "simulation"
)
page_logger("DEBUG", "Created Page 17 reactive data system for simulation")

# Observer for simulation data update button
observeEvent(input$simUpdateData,
  {
    page_logger("DEBUG", "Simulation data update button clicked")
    sim_cache_manager$request_data()
  },
  ignoreNULL = TRUE
)

# Reactive simulation data using the caching system (like raw tracker data)
sim_data <- reactive({
  req(input$sim_participant, input$sim_trialNum)
  participant <- input$sim_participant
  trial <- as.numeric(input$sim_trialNum)

  page_logger("DEBUG", "Getting simulation data for participant:", participant, "trial:", trial)

  # Only get data if it's already been loaded (trigger > 0)
  # Don't trigger automatic loading - only show what's already cached
  trigger_value <- sim_cache_manager$trigger()
  if (trigger_value > 0) {
    page_logger("DEBUG", "Data has been requested (trigger > 0), getting cached data")
    # Get cached data from reactive
    cached_data <- sim_cached_data()
    page_logger("DEBUG", "Cached data loaded:", nrow(cached_data), "rows")
  } else {
    page_logger("DEBUG", "No data request made yet (trigger = 0), returning empty data")
    return(data.frame())
  }

  if (nrow(cached_data) == 0) {
    page_logger("DEBUG", "No cached data available, returning empty structure")
    return(data.frame())
  }

  # Filter for the specific participant and trial
  filtered_data <- cached_data[
    cached_data$participant == participant &
      cached_data$trialNum == trial,
  ]

  page_logger("DEBUG", "Filtered data has", nrow(filtered_data), "rows for participant", participant, "trial", trial)

  if (nrow(filtered_data) == 0) {
    page_logger("WARN", "No simulation data found for participant", participant, "trial", trial)
    return(data.frame())
  }

  # Apply downsampling if specified
  if (!is.null(input$sim_downsampling) && input$sim_downsampling > 1) {
    page_logger("DEBUG", "Applying downsampling with factor:", input$sim_downsampling)
    indices <- seq(1, nrow(filtered_data), by = input$sim_downsampling)
    filtered_data <- filtered_data[indices, , drop = FALSE]
    page_logger("DEBUG", "After downsampling:", nrow(filtered_data), "rows")
  }

  return(filtered_data)
})

# Update data availability status
output$sim_data_status <- renderText({
  req(input$sim_participant, input$sim_trialNum)
  participant <- input$sim_participant
  trial <- as.numeric(input$sim_trialNum)

  tryCatch(
    {
      # Get current data using the same logic as sim_data()
      current_data <- sim_data()

      if (!is.null(current_data) && nrow(current_data) > 0) {
        n_real <- sum(current_data$simulating, na.rm = TRUE)
        n_respawns <- length(unique(current_data$respawn_segment)) - 1
        paste0(
          "✓ Simulation data available: ", nrow(current_data), " samples (", n_real, " on plate, ", n_respawns, " ball falls), arcDeg = ",
          paste(unique(current_data$arcDeg), collapse = ", ")
        )
      } else {
        # Check if any simulation data is cached at all
        all_cached_data <- sim_cached_data()
        if (nrow(all_cached_data) > 0) {
          total_participants <- length(unique(all_cached_data$participant))
          total_trials <- length(unique(all_cached_data$trialNum))
          total_samples <- nrow(all_cached_data)
          paste0(
            "✓ Simulation data cached: ", total_samples, " total samples (", total_participants, " participants, ", total_trials, " trials)\n",
            "✗ No data for current selection (participant ", participant, ", trial ", trial, ")"
          )
        } else {
          "No simulation data loaded. Click 'Update Simulation Data' to load and cache simulation data."
        }
      }
    },
    error = function(e) {
      paste("✗ Error checking simulation data:", e$message)
    }
  )
})

# Update variable choices when data changes
observe({
  req(input$sim_participant, input$sim_trialNum)

  # Use the reactive sim_data instead of calling get_simulation_data again
  data <- sim_data()
  if (is.null(data) || nrow(data) == 0) {
    updateSelectizeInput(session, "sim_vars", choices = NULL, selected = NULL)
    return()
  }

  # Update available variables
  available_vars <- get_simulation_variable_choices(data)
  if (!is.null(available_vars)) {
    # Preserve previously selected variables if they still exist
    prev <- isolate(input$sim_vars)
    keep <- intersect(prev, available_vars)
    if (length(keep) == 0) {
      keep <- intersect(c("q", "x", "dist_to_escape"), available_vars)
      if (length(keep) == 0) keep <- available_vars[1]
    }
    updateSelectizeInput(session, "sim_vars",
      choices = available_vars,
      selected = keep
    )
  }
})

# Time series plot
output$sim_tsPlot <- renderPlotly({
  data <- sim_data()
  vars <- input$sim_vars
  if (is.null(data) || nrow(data) == 0 || length(vars) == 0) {
    return(plotly::plot_ly() %>% layout(title = "No data/variables selected"))
  }

  # Use the plotting function
  tryCatch(
    {
      plot_simulation_timeseries(
        data = data,
        vars = vars,
        downsampling = input$sim_downsampling,
        plot_width = input$plotwidth,
        plot_height = input$plotheight
      )
    },
    error = function(e) {
      plot_ly() %>% layout(title = paste("Error:", e$message))
    }
  )
})

# Update risk model file choices
observe({
  # Get all .rds files in the data_extra directory
  if (dir.exists(dataExtraFolder)) {
    model_files <- list.files(dataExtraFolder, pattern = "\\.rds$", full.names = FALSE)
    # Filter for risk model files
    risk_model_files <- model_files[grepl("risk_model", model_files, ignore.case = TRUE)]

    if (length(risk_model_files) > 0) {
      # Set default to the main risk model file if it exists
      default_file <- if ("risk_model_v1.rds" %in% risk_model_files) "risk_model_v1.rds" else risk_model_files[1]
      updateSelectizeInput(session, "risk_model_file",
        choices = risk_model_files,
        selected = default_file
      )
    } else {
      updateSelectizeInput(session, "risk_model_file",
        choices = "No risk model files found",
        selected = NULL
      )
    }
  }
})


# Load selected risk model
observeEvent(input$load_risk_model, {
  req(input$risk_model_file)

  if (input$risk_model_file == "No risk model files found") {
    output$risk_model_status <- renderText("No risk model files available to load")
    return()
  }

  tryCatch(
    {
      model_path <- file.path(dataExtraFolder, input$risk_model_file)
      model <- load_risk_model(model_path)

      if (!is.null(model)) {
        # Load into global workspace
        GLOBAL_RISK_MODEL <<- model
        output$risk_model_status <- renderText(
          sprintf(
            "✓ Risk model loaded successfully: %s (class: %s)",
            input$risk_model_file, class(model)[1]
          )
        )
      } else {
        output$risk_model_status <- renderText("✗ Failed to load risk model")
      }
    },
    error = function(e) {
      output$risk_model_status <- renderText(paste("✗ Error loading risk model:", e$message))
    }
  )
})

# Risk model training
observeEvent(input$train_risk_model, {
  # The caching system will automatically get participants/trials from sidebar filters
  # and validate that simulation data exists (datasets_to_verify = c("sim"))

  # Update status
  output$risk_model_status <- renderText("Starting risk model training using sidebar filters...")

  # Train the model
  tryCatch(
    {
      # Step 1: Data collection
      output$risk_model_status <- renderText("Step 1/3: Collecting hazard samples from all trials...")

      model <- train_and_save_risk_model(
        tau = input$risk_tau,
        sampling_freq = input$sampling_freq
      )

      if (!is.null(model)) {
        # Load the new model into global workspace
        GLOBAL_RISK_MODEL <<- model

        # Get model summary for status
        model_summary <- summary(model)
        n_obs <- nrow(model@frame)

        output$risk_model_status <- renderText(
          sprintf(
            "✓ Risk model trained and loaded successfully! Used %d observations from sidebar-selected participants and trials. Model saved to %s and loaded into global workspace.",
            n_obs,
            risk_model_path
          )
        )
      } else {
        output$risk_model_status <- renderText("Failed to train risk model - no valid data found")
      }
    },
    error = function(e) {
      output$risk_model_status <- renderText(paste("Error training risk model:", e$message))
    }
  )
})

# Update hazard cache using caching system
observeEvent(input$update_hazard_cache, {
  req(input$risk_model_file)

  if (input$risk_model_file == "No risk model files found") {
    output$risk_model_status <- renderText("No risk model files available to load")
    return()
  }

  tryCatch(
    {
      # Load risk model first
      model_path <- file.path(dataExtraFolder, input$risk_model_file)
      model <- load_risk_model(model_path)

      if (is.null(model)) {
        output$risk_model_status <- renderText("Failed to load risk model")
        return()
      }

      # Update status
      output$risk_model_status <- renderText("Updating hazard cache using caching system...")

      # Update status
      output$risk_model_status <- renderText("Adding predictions to hazard samples and saving to cache...")

      # Annotate hazard samples with fixed-effects predictions and save to cache
      # This will automatically load hazard samples from cache if NULL is passed
      # This is a standalone transformation that loads from cache and saves to cache
      # (though you can also pass model and hazard_samples to the function)
      hazard_samples <- annotate_hazard_predictions(
        model = NULL, # Load from cache
        hazard_samples = NULL, # Load from cache
        include_re = FALSE,
        out_path = "cache" # Save to cache system
      )

      if (is.null(hazard_samples) || nrow(hazard_samples) == 0) {
        output$risk_model_status <- renderText("Failed to retrieve hazard samples from cache or samples are empty")
        return()
      }

      # Model is now loaded into cache system automatically

      # Show success popup
      n_participants <- length(unique(hazard_samples$participant))
      n_samples <- nrow(hazard_samples)

      showModal(modalDialog(
        title = "✓ Hazard Cache Updated & Model Applied Successfully!",
        paste0(
          "Retrieved ", n_samples, " hazard samples from ",
          n_participants, " participants using caching system\n\n",
          "Model applied and predictions computed.\n",
          "Hazard samples with predictions saved to cache system.\n\n",
          "Click 'Perform Risk Analysis' to compute standardized risks and statistical analysis."
        ),
        easyClose = TRUE,
        size = "m",
        footer = modalButton("Close")
      ))

      # Clear the status text
      output$risk_model_status <- renderText("")
    },
    error = function(e) {
      output$risk_model_status <- renderText(paste("Error updating hazard cache:", e$message))
    }
  )
})

# Perform Risk Analysis button handler
observeEvent(input$perform_risk_analysis, {
  # Check if we have the required model
  if (is.null(GLOBAL_RISK_MODEL)) {
    output$risk_model_status <- renderText("Please load a risk model first")
    return()
  }

  tryCatch(
    {
      # Get hazard samples with predictions from cache system
      output$risk_model_status <- renderText("Loading hazard samples with predictions from cache...")

      hazard_samples <- get_cached_data(
        data_type = "hazard_preds",
        participants = NULL, # Will be determined by caching system from sidebar
        trials = NULL, # Will be determined by caching system from sidebar
        condition_filter = NULL,
        use_parallel = TRUE,
        shiny_inputs = input
      )

      if (is.null(hazard_samples) || nrow(hazard_samples) == 0) {
        output$risk_model_status <- renderText("No hazard samples with predictions found in cache. Please update cache first.")
        return()
      }

      # Get the stored model
      model <- GLOBAL_RISK_MODEL

      # Perform the risk analysis
      output$risk_model_status <- renderText("Computing pooled standardized risks...")

      # Use the compute_pooled_standardized_risks function
      results <- compute_pooled_standardized_risks(
        model = model,
        hazard_samples = hazard_samples
      )

      # Analysis results are now handled by the caching system

      # Show success popup with plot
      n_combinations <- nrow(results$standardized_risks)
      n_participants <- length(unique(hazard_samples$participant))
      n_samples <- nrow(hazard_samples)

      # Create popup message with plot
      showModal(modalDialog(
        title = "✓ Risk Analysis Completed Successfully!",
        paste0(
          "Results: ", n_combinations, " condition × phase combinations from ",
          n_samples, " samples (", n_participants, " participants)\n\n",
          "Statistical analysis completed and results saved to files.\n",
          "Analysis results stored in GLOBAL_HAZARD_ANALYSIS_RESULTS"
        ),
        plotOutput("risk_analysis_plot", height = "400px"),
        easyClose = TRUE,
        size = "l",
        footer = modalButton("Close")
      ))

      # Render the plot in the modal
      output$risk_analysis_plot <- renderPlot({
        results$analysis_results$plot
      })

      # Clear the status text
      output$risk_model_status <- renderText("")
    },
    error = function(e) {
      output$risk_model_status <- renderText(paste("Error performing risk analysis:", e$message))
    }
  )
})
```