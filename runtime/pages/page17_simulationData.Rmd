### Plot Options
```{r}
# Participant and trial selection
selectizeInput("sim_participant", "Participant",
  choices = participants, selected = participants[1], multiple = FALSE
)
selectizeInput("sim_trialNum", "Trial Number",
  choices = allTrials, selected = allTrials[3], multiple = FALSE
)


# Variable selection for time series
selectizeInput("sim_vars", "Time-series variables",
  choices = NULL, multiple = TRUE
)

# Downsampling
numericInput("sim_downsampling", "Downsample factor",
  value = 1, min = 1, step = 1
)

# Risk predictions toggle
checkboxInput("enable_risk_predictions", "Enable Risk Predictions",
  value = FALSE, width = "100%"
)

# Tau parameter for risk predictions
numericInput("risk_tau", "Risk Prediction Time Horizon (seconds)",
  value = 0.2, min = 0, max = 5, step = 0.1, width = "100%"
)

# Sampling frequency for model training
numericInput("sampling_freq", "Sampling Frequency for Training (Hz)",
  value = 90, min = 1, max = 200, step = 1, width = "100%"
)

# Risk model training
actionButton("train_risk_model", "Train Drop Risk Model",
  class = "btn-primary", style = "margin-top: 10px;"
)
textOutput("risk_model_status")
```

Column
--------------------------------------------

### Simulation Data Availability
```{r}
textOutput("sim_data_status")
```

### Time Series Plot {data-height=600}
Shows selected variables over time.
```{r}
plotlyOutput("sim_tsPlot")
```

```{r, context="server"}
# Reactive simulation data
sim_data <- reactive({
  req(input$sim_participant, input$sim_trialNum)
  participant <- input$sim_participant
  trial <- as.numeric(input$sim_trialNum)

  # Check if simulation data exists
  if (!has_simulation_data(participant, trial)) {
    return(NULL)
  }

  # Get the simulation data with UI parameters
  get_simulation_data(
    participant,
    trial,
    enable_risk = input$enable_risk_predictions,
    tau = input$risk_tau
  )
})

# Update data availability status
output$sim_data_status <- renderText({
  req(input$sim_participant, input$sim_trialNum)
  participant <- input$sim_participant
  trial <- as.numeric(input$sim_trialNum)

  tryCatch(
    {
      if (has_simulation_data(participant, trial)) {
        # Use the reactive sim_data instead of calling get_simulation_data again
        data <- sim_data()
        if (!is.null(data) && nrow(data) > 0) {
          n_real <- sum(data$simulating, na.rm = TRUE)
          n_respawns <- length(unique(data$respawn_segment)) - 1
          paste0(
            "✓ Simulation data available: ", nrow(data), " total samples (", n_real, " on plate, ", n_respawns, " ball falls), arcDeg = ",
            paste(unique(data$arcDeg), collapse = ", ")
          )
        } else {
          "✗ Error loading simulation data"
        }
      } else {
        "✗ No simulation data available for this participant/trial"
      }
    },
    error = function(e) {
      paste("✗ Error checking simulation data:", e$message)
    }
  )
})

# Update variable choices when data changes
observe({
  req(input$sim_participant, input$sim_trialNum)

  # Use the reactive sim_data instead of calling get_simulation_data again
  data <- sim_data()
  if (is.null(data) || nrow(data) == 0) {
    updateSelectizeInput(session, "sim_vars", choices = NULL, selected = NULL)
    return()
  }

  # Update available variables
  available_vars <- get_simulation_variable_choices(data)
  if (!is.null(available_vars)) {
    # Preserve previously selected variables if they still exist
    prev <- isolate(input$sim_vars)
    keep <- intersect(prev, available_vars)
    if (length(keep) == 0) {
      keep <- intersect(c("q", "x", "dist_to_escape"), available_vars)
      if (length(keep) == 0) keep <- available_vars[1]
    }
    updateSelectizeInput(session, "sim_vars",
      choices = available_vars,
      selected = keep
    )
  }
})

# Time series plot
output$sim_tsPlot <- renderPlotly({
  data <- sim_data()
  vars <- input$sim_vars
  if (is.null(data) || nrow(data) == 0 || length(vars) == 0) {
    return(plotly::plot_ly() %>% layout(title = "No data/variables selected"))
  }

  # Use the plotting function
  tryCatch(
    {
      plot_simulation_timeseries(
        data = data,
        vars = vars,
        downsampling = input$sim_downsampling,
        plot_width = input$plotwidth,
        plot_height = input$plotheight
      )
    },
    error = function(e) {
      plot_ly() %>% layout(title = paste("Error:", e$message))
    }
  )
})

# Risk model training
observeEvent(input$train_risk_model, {
  # Use the current sidebar filters for participants and trials
  selected_participants <- input$filterParticipants
  selected_trials <- input$filterTrials

  if (is.null(selected_participants) || is.null(selected_trials) ||
    length(selected_participants) == 0 || length(selected_trials) == 0) {
    output$risk_model_status <- renderText("Please select participants and trials in the sidebar first")
    return()
  }

  # Filter to only include trials that have simulation data
  # Create all combinations first, then filter efficiently
  all_combinations <- expand.grid(
    participant = selected_participants,
    trial = selected_trials,
    stringsAsFactors = FALSE
  )

  # Check which combinations have simulation data
  has_data <- mapply(has_simulation_data, all_combinations$participant, all_combinations$trial)
  valid_combinations <- all_combinations[has_data, ]

  # Remove any duplicates (just in case)
  valid_combinations <- unique(valid_combinations)

  if (nrow(valid_combinations) == 0) {
    output$risk_model_status <- renderText("No simulation data available for selected participants/trials")
    return()
  }

  # Update status
  output$risk_model_status <- renderText(
    sprintf("Found %d valid participant-trial combinations. Starting data collection...", nrow(valid_combinations))
  )

  # Train the model
  tryCatch(
    {
      # Step 1: Data collection
      output$risk_model_status <- renderText("Step 1/3: Collecting hazard samples from all trials...")

      model <- train_and_save_risk_model(
        participants = valid_combinations$participant,
        trials = valid_combinations$trial,
        tau = input$risk_tau,
        sampling_freq = input$sampling_freq
      )

      if (!is.null(model)) {
        # Get model summary for status
        model_summary <- summary(model)
        n_obs <- nrow(model@frame)

        output$risk_model_status <- renderText(
          sprintf(
            "Risk model trained successfully! Used %d participants, %d trials, %d observations. Model saved to %s",
            length(unique(valid_combinations$participant)),
            nrow(valid_combinations),
            n_obs,
            risk_model_path
          )
        )
      } else {
        output$risk_model_status <- renderText("Failed to train risk model - no valid data found")
      }
    },
    error = function(e) {
      output$risk_model_status <- renderText(paste("Error training risk model:", e$message))
    }
  )
})
```