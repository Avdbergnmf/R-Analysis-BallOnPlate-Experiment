### Actions

```{r}
# Add JavaScript for table row highlighting without re-rendering
tags$script(HTML("
  // Handle custom messages for table row highlighting
  Shiny.addCustomMessageHandler('highlightTableRow', function(message) {
    var table = $('#' + message.tableId).DataTable();
    
    // Clear existing highlights
    $('#' + message.tableId + ' tbody tr').removeClass('highlighted-row');
    
    // Add highlight to the specified row
    var row = table.row(message.rowIndex);
    if (row.length > 0) {
      $(row.node()).addClass('highlighted-row');
    }
  });
  
  Shiny.addCustomMessageHandler('clearTableHighlight', function(message) {
    $('#' + message.tableId + ' tbody tr').removeClass('highlighted-row');
  });
"))

# Add CSS for the highlight style
tags$style(HTML("
  .highlighted-row {
    background-color: rgba(255, 255, 0, 0.7) !important;
  }
  
  .highlighted-row td {
    background-color: rgba(255, 255, 0, 0.7) !important;
  }
"))
```

```{r}
selectizeInput("participant", "participant",
  choices = participants, selected = participants[1], multiple = FALSE)
selectizeInput("trialNum", "Trial Number",
  choices = allTrials, selected = allTrials[4], multiple = FALSE) # set to trial 2 so that if practice is filtered out, it still plots
selectizeInput("xplot_16", "xplot",
  choices = xOptions, selected = "time", multiple = FALSE)#xOptions[2]
selectizeInput("yplot_16", "yplot",
  choices = xOptions, selected = "pos_x", multiple = FALSE)#xOptions[3]

# Add x and y limits inputs
numericInput("xlim_min_16", "X-axis minimum",
  min = -Inf, max = Inf, value = 0, step = 0.1)
numericInput("xlim_max_16", "X-axis maximum",
  min = -Inf, max = Inf, value = 20, step = 0.1)
numericInput("ylim_min_16", "Y-axis minimum",
  min = -Inf, max = Inf, value = -.5, step = 0.1)
numericInput("ylim_max_16", "Y-axis maximum",
  min = -Inf, max = Inf, value = .5, step = 0.1)
# Add a reset button to reset the axis limits
actionButton("reset_limits", "Reset Axis Limits")
actionButton("refresh_plot", "Refresh Plot")
```
```{r}
# Add a numeric input for the outlier matching threshold
numericInput("outlier_threshold", "Outlier matching threshold (seconds)",
  min = 0, max = 1, value = 0.01, step = 0.001)

# New: choose how the clicked heel-strike should be treated
radioButtons("outlier_action", "Heel-strike action", choices = c(
  "Remove step" = "KILL",
  "Keep as boundary" = "KEEP"),
  selected = "KILL", inline = TRUE)

fileInput("importOutliers", "Import Outliers from CSV",
  accept = c("text/csv", "text/comma-separated-values,text/plain", ".csv"))
downloadButton("export_outliers", "Export Outliers to CSV")
```

```{r}
#actionButton("confirm_selection", "Confirm Selected Points") # not using this atm.
```

```{r}
actionButton("overwrite_outliers", "Overwrite Outliers")
```
.
Autosaving:
```{r}
# Add these new inputs for autosave configuration
numericInput("autosave_interval", "Autosave interval (minutes)",
             value = 5, min = 1, max = 60, step = 1)
checkboxInput("do_autosave", "Enable autosave", value = FALSE)
```

Save allGaitParams to RDS.
```{r}
downloadButton("save_rds", "Save current parameters to RDS.")
```


Column
--------------------------------------------
### Foot Trajectories {data-width=650 data-height=1500}
This interface was used to manually select the incorrectly detected steps as outliers so they could be removed from the dataset.

Click a heel strike to add it to outlier list. It's wise to enable the auto-saving feature if you wish to reproduce this, as this takes quite some time, and the interface crashes randomly from time to time. You can also browse to the saved outliers (in the `data_extra` folder) and load them to load this list into the interface.

Also be aware that the data shown here is also based on the selection of data in the sidebar (this may already have some steps/trials filtered out).

Finally, this also includes a button on the left to save the new outliers to a `.rds` file (you can use this to overwrite the original automatic calculation of the outliers, which is far from correct).

```{r}
plotlyOutput("manualOutlierPlot")
```

Column
--------------------------------------------
### Selected Outliers  {data-width=350 data-height=1500}

```{r}
# Add this new checkbox input above the DataTable
checkboxInput("filter_outliers_table", "Filter table by current participant and trial", value = TRUE)
checkboxInput("show_outliers_on_plot", "Show outliers on plot (disable for large datasets)", value = TRUE)
```

**Outlier Actions:**
- **❌ Remove Step** (unchecked): Completely excludes the step from all analyses  
- **➡️ Keep as Boundary** (checked): Keeps step data but marks heel-strike as suspect
- Use the **Toggle** column checkboxes to change between actions
- **Hover** over outliers on the plot to highlight them in the table
- Click heel strikes on the plot to add/remove outliers entirely

**Plot Symbols:**
- **❌ (Red X)**: KILL outliers - completely removed from analysis
- **▲ (Blue Triangle)**: KEEP outliers - preserved as boundary markers

```{r}
DT::dataTableOutput("selectedOutliersTable")
```

```{r, context="server"}

# Initialize a reactive value for plot refresh trigger
refresh_trigger <- reactiveVal(0)
last_refresh_trigger <- reactiveVal(0)

# Initialize a reactive value for tracking table content changes
table_content_hash <- reactiveVal(NULL)

observeEvent(input$importOutliers, {
  req(input$importOutliers)
  tryCatch(
    {
      df <- read.csv(input$importOutliers$datapath, stringsAsFactors = FALSE)
      # Check for either new format (time) or legacy format (heelStrikes.time)
    has_new_format <- all(c("participant", "trialNum", "time") %in% colnames(df))
    has_legacy_format <- all(c("participant", "trialNum", "heelStrikes.time") %in% colnames(df))
    
    if (has_new_format || has_legacy_format) {
        # Convert trialNum to numeric if it's not already
        df$trialNum <- as.numeric(df$trialNum)
        
        # Standardize to use 'time' column
        if (has_legacy_format && !has_new_format) {
          df$time <- df$heelStrikes.time
          df$heelStrikes.time <- NULL
        }
        
        # Add action column if missing (backward compatibility)
        if (!"action" %in% colnames(df)) {
          df$action <- "KILL"  # Default to KILL for imported outliers
          showNotification("Added default 'KILL' action to imported outliers without action column", type = "message")
        }
        
        # Ensure action column has valid values
        df$action[!df$action %in% c("KILL", "KEEP")] <- "KILL"
        
        # Update the selected_outliers reactive value
        selected_outliers(df)
        showNotification(paste("Outliers imported successfully:", nrow(df), "outliers loaded"), type = "message")
        # Don't immediately refresh to avoid freezing - let user navigate to see the results
        # refresh_trigger(refresh_trigger() + 1)
      } else {
        showNotification("Invalid CSV format. Please ensure the file has 'participant', 'trialNum', and either 'time' or 'heelStrikes.time' columns.", type = "error")
      }
    },
    error = function(e) {
      showNotification(paste("Error importing outliers:", e$message), type = "error")
    }
  )
})

# Reactive value to store selected outliers
selected_outliers <- reactiveVal(data.frame(
  participant = character(),
  trialNum = numeric(),
  time = numeric(),
  action = character(),
  stringsAsFactors = FALSE
))

# Add this new reactive to store the current outliers
current_outliers <- reactive({
  selected_outliers() %>%
    dplyr::filter(participant == input$participant & trialNum == as.numeric(input$trialNum))
})

# Reactive values to store current axis limits
axis_limits <- reactiveValues(x = NULL, y = NULL)

# Initialize axis limits when the app starts or when reset button is clicked
observe({
  # Initialize or reset axis limits to the input values
  axis_limits$x <- c(input$xlim_min_16, input$xlim_max_16)
  axis_limits$y <- c(input$ylim_min_16, input$ylim_max_16)
})

# Reset axis limits when the reset button is clicked
observeEvent(input$reset_limits, {
  # Reset axis limits to the input values
  axis_limits$x <- c(input$xlim_min_16, input$xlim_max_16)
  axis_limits$y <- c(input$ylim_min_16, input$ylim_max_16)
  refresh_trigger(refresh_trigger() + 1)
})


# Set initial axis limits based on the inputs (inside a reactive context)
observeEvent(input$refresh_plot, {
  # Only set axis limits if they haven't been manually set yet
  if (is.null(axis_limits$x)) {
    axis_limits$x <- c(input$xlim_min_16, input$xlim_max_16)
  }
  if (is.null(axis_limits$y)) {
    axis_limits$y <- c(input$ylim_min_16, input$ylim_max_16)
  }
  
  # Show warning if there are many outliers and auto-disable if too many
  num_outliers <- nrow(selected_outliers())
  if (num_outliers > 500) {
    updateCheckboxInput(session, "show_outliers_on_plot", value = FALSE)
    showNotification(paste("Auto-disabled outlier display due to", num_outliers, "outliers. Enable manually if needed."), 
                     type = "warning", duration = 5)
  } else if (num_outliers > 100) {
    showNotification(paste("Refreshing plot with", num_outliers, "outliers - this may take a moment..."), 
                     type = "message", duration = 3)
  }
  
  refresh_trigger(refresh_trigger() + 1)
})

# Observe changes in the plot's layout to update axis limits
observeEvent(event_data("plotly_relayout"), {
  relayout_data <- event_data("plotly_relayout")
  #print(relayout_data)  # Debugging: see what Plotly sends on relayout

  # Update x-axis limits
  if (!is.null(relayout_data[["xaxis.range[0]"]]) && !is.null(relayout_data[["xaxis.range[1]"]])) {
    axis_limits$x <- c(relayout_data[["xaxis.range[0]"]], relayout_data[["xaxis.range[1]"]])
  } else if (!is.null(relayout_data$xaxis.range)) {
    axis_limits$x <- relayout_data$xaxis.range
  }

  # Update y-axis limits
  if (!is.null(relayout_data[["yaxis.range[0]"]]) && !is.null(relayout_data[["yaxis.range[1]"]])) {
    axis_limits$y <- c(relayout_data[["yaxis.range[0]"]], relayout_data[["yaxis.range[1]"]])
  } else if (!is.null(relayout_data$yaxis.range)) {
    axis_limits$y <- relayout_data$yaxis.range
  }
})

# Update selected outliers based on plot clicks
observeEvent(event_data("plotly_click"), {
  click_data <- event_data("plotly_click")
  
  if (!is.null(click_data)) {
    current_participant <- input$participant
    current_trial <- as.numeric(input$trialNum)
    clicked_time <- click_data$x
    
    # Find the closest heel strike in filteredParams()
    params <- filteredParams()
    closest_step <- params[params$participant == current_participant &
                               params$trialNum == current_trial, ] %>%
      mutate(time_diff = abs(time - clicked_time)) %>%
      arrange(time_diff) %>%
      slice(1)
    
    if (nrow(closest_step) > 0 && closest_step$time_diff <= 0.25) {
      current_outliers <- selected_outliers()
      
      # Check if the clicked outlier already exists in the list
      existing_outlier <- current_outliers %>%
        dplyr::filter(participant == closest_step$participant,
               trialNum == closest_step$trialNum,
               abs(time - closest_step$time) <= input$outlier_threshold)
      
      if (nrow(existing_outlier) > 0) {
        # Remove the outlier
        updated_outliers <- current_outliers %>%
          dplyr::filter(!(participant == closest_step$participant &
                   trialNum == closest_step$trialNum &
                   abs(time - closest_step$time) <= input$outlier_threshold))
        selected_outliers(updated_outliers)
        showNotification("Outlier removed", type = "message")
      } else {
        # Add the outlier
        new_outlier <- data.frame(
          participant = closest_step$participant,
          trialNum    = closest_step$trialNum,
          time        = closest_step$time,
          action      = input$outlier_action,
          stringsAsFactors = FALSE
        )
        updated_outliers <- rbind(current_outliers, new_outlier)
        selected_outliers(updated_outliers)
        showNotification("Outlier added", type = "message")
      }
    }
  }
})

# Optimize the plot rendering with caching
plot_cache <- reactiveVal(NULL)
plot_participant <- reactiveVal(NULL)
plot_trial <- reactiveVal(NULL)
plot_xaxis <- reactiveVal(NULL)
plot_yaxis <- reactiveVal(NULL)

# Render the interactive plot
output$manualOutlierPlot <- renderPlotly({
  
  # Check if we need to regenerate the base plot
  current_participant <- input$participant
  current_trial <- as.numeric(input$trialNum)
  current_xaxis <- input$xplot_16
  current_yaxis <- input$yplot_16
  
  # Only regenerate base plot if parameters changed or forced refresh
  current_refresh_trigger <- refresh_trigger()
  need_new_plot <- is.null(plot_cache()) || 
                   plot_participant() != current_participant || 
                   plot_trial() != current_trial ||
                   plot_xaxis() != current_xaxis ||
                   plot_yaxis() != current_yaxis ||
                   current_refresh_trigger != last_refresh_trigger()  # Only if refresh was triggered
  
  if (need_new_plot) {
    # Check if we have data to plot
    plot_data <- filteredParams()
    if (is.null(plot_data) || nrow(plot_data) == 0) {
      return(plot_ly() %>% 
        layout(title = "No data available for the selected participant/trial"))
    }
    
    # Create the base ggplot
    base_plot <- tryCatch({
      plot_steps(
        plot_data, current_participant, current_trial,
        current_xaxis, current_yaxis, input$filter, 
        baseSize = input$baseSize
      )
    }, error = function(e) {
      warning("Error creating base plot: ", e$message)
      return(plot_ly() %>% layout(title = paste("Error creating plot:", e$message)))
    })
    
    # Cache the base plot and parameters
    plot_cache(base_plot)
    plot_participant(current_participant)
    plot_trial(current_trial)  
    plot_xaxis(current_xaxis)
    plot_yaxis(current_yaxis)
    last_refresh_trigger(current_refresh_trigger)  # Update the last trigger value
  } else {
    # Use cached base plot
    base_plot <- plot_cache()
  }
  
  # Ensure base plot exists
  if (is.null(base_plot)) {
    return(plot_ly() %>% 
      layout(title = "Unable to generate plot"))
  }

  # Always update outlier highlighting (this is fast)
  req(filteredParams())
  
  # Get the current data for this participant and trial
  current_data <- filteredParams() %>%
    dplyr::filter(participant == current_participant & trialNum == current_trial)
  
  # Get current outliers - optimize with vectorized operations
  current_outliers_data <- current_outliers()
  
  # Efficient outlier matching - only if user wants to show outliers on plot
  if (input$show_outliers_on_plot && nrow(current_outliers_data) > 0 && nrow(current_data) > 0) {
    # Show progress for large outlier datasets
    if (nrow(current_outliers_data) > 50) {
      showNotification(paste("Processing", nrow(current_outliers_data), "outliers..."), 
                       type = "message", duration = 1)
    }
    
    # Use a much more efficient approach with binning
    threshold <- input$outlier_threshold
    
    # Create expanded ranges for each outlier
    outlier_ranges <- data.frame(
      start = current_outliers_data$time - threshold,
      end = current_outliers_data$time + threshold
    )
    
    # Check if each data point falls within any outlier range
    # This is much faster than nested loops
    is_outlier <- logical(nrow(current_data))
    
    for (i in seq_len(nrow(outlier_ranges))) {
      within_range <- current_data$time >= outlier_ranges$start[i] & 
                      current_data$time <= outlier_ranges$end[i]
      is_outlier <- is_outlier | within_range
    }
    
    current_data$is_outlier <- is_outlier
  } else {
    current_data$is_outlier <- FALSE
  }
  
  # suspect column present
  if (!"suspect" %in% colnames(current_data)) current_data$suspect <- FALSE
  
  # Add outlier highlighting to the plot with different symbols for different actions
  # First add suspect points (orange)
  p <- base_plot + 
    geom_point(data = current_data %>% dplyr::filter(suspect),
               aes(x = .data[[current_xaxis]],
                   y = .data[[current_yaxis]]),
               color = "orange", size = 4, shape = 21, fill = "orange", alpha = 0.6)
  
  # Add KILL outliers (X symbol)
  kill_outliers <- current_data %>% dplyr::filter(is_outlier)
  if (nrow(kill_outliers) > 0) {
    # Match outliers with their actions from the outlier data
    kill_outliers$action_type <- sapply(seq_len(nrow(kill_outliers)), function(i) {
      outlier_result <- check_outlier_heel_strike(current_participant, current_trial, 
                                                 kill_outliers$time[i], input$outlier_threshold)
      if (outlier_result$is_outlier) {
        return(outlier_result$action)
      } else {
        return("KILL")  # Default
      }
    })
    
    # Add KILL outliers (X symbol, red)
    kill_data <- kill_outliers %>% dplyr::filter(action_type == "KILL")
    if (nrow(kill_data) > 0) {
      p <- p + geom_point(data = kill_data,
                         aes(x = .data[[current_xaxis]],
                             y = .data[[current_yaxis]],
                             text = paste("KILL Outlier<br>Time:", round(time, 3),
                                        "<br>Participant:", participant,
                                        "<br>Trial:", trialNum)),
                         color = "red", size = 6, shape = 4, alpha = 0.8)  # Shape 4 = X
    }
    
    # Add KEEP outliers (arrow symbol, blue)
    keep_data <- kill_outliers %>% dplyr::filter(action_type == "KEEP")
    if (nrow(keep_data) > 0) {
      p <- p + geom_point(data = keep_data,
                         aes(x = .data[[current_xaxis]],
                             y = .data[[current_yaxis]],
                             text = paste("KEEP Outlier<br>Time:", round(time, 3),
                                        "<br>Participant:", participant,
                                        "<br>Trial:", trialNum)),
                         color = "blue", size = 6, shape = 17, alpha = 0.8)  # Shape 17 = triangle (arrow-like)
    }
  }
  
  # Capture current limits once to avoid reactivity
  x_range_init <- isolate(axis_limits$x)
  y_range_init <- isolate(axis_limits$y)
  
  # Convert to plotly (no reactive dependency on axis_limits)
  p <- ggplotly(p, width = input$plotwidth, height = input$plotheight, tooltip = "text") %>%
    style(
      hoverinfo = "none",
      traces = which(sapply(.$x$data, function(d) d$type) == "scatter" & sapply(.$x$data, function(d) d$mode) == "lines")
    ) %>%
    layout(
      dragmode = "pan",
      xaxis = list(
        range = x_range_init,
        tickmode = "linear",
        dtick = 1,
        tick0 = 0
      ),
      yaxis = list(range = y_range_init)
    ) %>%
    event_register("plotly_click") %>% 
    event_register("plotly_selected") %>%
    event_register("plotly_hover") %>%
    event_register("plotly_unhover")
  
  return(p)
})



# Render the selected outliers table
output$selectedOutliersTable <- DT::renderDataTable({
  # Apply filtering only if the checkbox is checked
  current_participant <- input$participant
  current_trial <- as.numeric(input$trialNum)
  if (input$filter_outliers_table) {
    filtered_outliers <- current_outliers()
  } else {
    filtered_outliers <- selected_outliers()
  }
  
  # Create a simple hash of the table content to detect actual changes
  content_for_hash <- paste(
    nrow(filtered_outliers),
    if(nrow(filtered_outliers) > 0) {
      # Simple hash based on key columns
      paste(filtered_outliers$participant, filtered_outliers$trialNum, 
            round(filtered_outliers$time, 4), filtered_outliers$action, collapse = "|")
    } else "",
    input$filter_outliers_table,
    current_participant,
    current_trial,
    sep = "_"
  )
  
  # Only proceed with full re-render if content actually changed
  if (is.null(table_content_hash()) || table_content_hash() != content_for_hash) {
    table_content_hash(content_for_hash)
  }
  
  filtered_outliers <- filtered_outliers %>%
    dplyr::mutate(
      # Create stable unique identifiers for each outlier
      unique_id = paste0("toggle_", 
                        gsub("[^A-Za-z0-9]", "_", participant), "_",
                        trialNum, "_",
                        round(time * 1000)),  # Convert to milliseconds for uniqueness
      # Add a user-friendly action description with symbols
      Action_Type = ifelse(action == "KILL", "❌ Remove Step", "➡️ Keep as Boundary"),
      # Create checkbox column for toggling action using stable IDs
      Toggle_Action = paste0('<input type="checkbox" id="', unique_id, '" ', 
                            ifelse(action == "KEEP", 'checked', ''), 
                            ' onchange="Shiny.setInputValue(\'', unique_id, '\', this.checked, {priority: \'event\'})">'),
      # Round time for better display
      time = round(time, 4)
    ) %>% 
    dplyr::arrange(desc(time)) %>%  # Sort by time instead of row_num
    dplyr::select(participant, trialNum, time, Action_Type, Toggle_Action) %>%
    dplyr::rename(
      Participant = participant,
      Trial = trialNum,
      Time = time,
      "Action Type" = Action_Type,
      "Toggle (✓ = Keep)" = Toggle_Action
    )
  
        # Create the base datatable with state preservation
  dt_table <- DT::datatable(
    filtered_outliers,
    options = list(
      pageLength = 100,
      search = NULL, #list(regex = TRUE, caseInsensitive = TRUE)
      columnDefs = list(
        list(targets = 4, orderable = FALSE) # Make toggle column non-sortable
      ),
      # Preserve table state across re-renders
      stateSave = TRUE,
      stateDuration = 60 * 60, # Save state for 1 hour
      # Preserve order, search, pagination
      order = list(list(2, 'desc')), # Default sort by Time column (index 2) descending
      # More stable rendering
      deferRender = TRUE,
      processing = FALSE
    ),
    selection = 'none',  # Disable row selection
    escape = FALSE  # Allow HTML in the toggle column
  ) %>%
    DT::formatStyle(
      columns = c('Participant', 'Trial'),
      backgroundColor = DT::styleEqual(
        c(current_participant, current_trial),
        c('rgba(255, 255, 0, 0.5)', 'rgba(255, 255, 0, 0.5)')
      )
    ) %>%
    DT::formatStyle(
      columns = 'Action Type',
      backgroundColor = DT::styleEqual(
        c('❌ Remove Step', '➡️ Keep as Boundary'),
        c('rgba(255, 100, 100, 0.3)', 'rgba(100, 255, 100, 0.3)')
      )
    )
  
  # Note: Hover highlighting is now handled separately to preserve table state
  
  return(dt_table)
})

# Handle checkbox toggles for action type changes
# Use a more stable approach with unique identifiers
observe({
  current_outliers_data <- selected_outliers()
  
  if (nrow(current_outliers_data) > 0) {
    # Create stable unique identifiers for each outlier
    for (i in seq_len(nrow(current_outliers_data))) {
      # Create a unique ID based on participant, trial, and time
      unique_id <- paste0("toggle_", 
                         gsub("[^A-Za-z0-9]", "_", current_outliers_data$participant[i]), "_",
                         current_outliers_data$trialNum[i], "_",
                         round(current_outliers_data$time[i] * 1000))  # Convert to milliseconds for uniqueness
      
      toggle_input_name <- unique_id
      
      if (!is.null(input[[toggle_input_name]])) {
        # Get the current state of the checkbox
        is_checked <- input[[toggle_input_name]]
        new_action <- ifelse(is_checked, "KEEP", "KILL")
        
        # Update the action for this outlier if it has changed
        if (current_outliers_data$action[i] != new_action) {
          # Use isolate to prevent reactive dependency loop
          isolate({
            updated_data <- selected_outliers()
            updated_data$action[i] <- new_action
            selected_outliers(updated_data)
          })
          
          # Show notification
          action_desc <- ifelse(new_action == "KILL", "Remove Step", "Keep as Boundary")
          showNotification(
            paste("Changed outlier action to:", action_desc, 
                  "for participant", current_outliers_data$participant[i],
                  "trial", current_outliers_data$trialNum[i],
                  "at time", round(current_outliers_data$time[i], 3)),
            type = "message",
            duration = 2
          )
          
          # Break after first change to avoid multiple updates in one cycle
          break
        }
      }
    }
  }
})

# Create a proxy for the data table to handle hover highlighting without full re-renders
table_proxy <- DT::dataTableProxy('selectedOutliersTable')

# Handle plot hover events for table highlighting using JavaScript
observeEvent(event_data("plotly_hover"), {
  hover_data <- event_data("plotly_hover")
  
  if (!is.null(hover_data) && !is.null(hover_data$x)) {
    current_participant <- input$participant
    current_trial <- as.numeric(input$trialNum)
    hovered_time <- hover_data$x
    
    # Check if this is an outlier point
    outlier_result <- check_outlier_heel_strike(current_participant, current_trial, 
                                               hovered_time, input$outlier_threshold)
    
    if (outlier_result$is_outlier) {
      # Find the matching row in the current table data
      current_data <- if (input$filter_outliers_table) current_outliers() else selected_outliers()
      
      if (nrow(current_data) > 0) {
        # Find matching row by time (with tolerance)
        time_matches <- abs(current_data$time - hovered_time) <= input$outlier_threshold
        participant_matches <- current_data$participant == current_participant
        trial_matches <- current_data$trialNum == current_trial
        
        matching_rows <- which(time_matches & participant_matches & trial_matches)
        
        if (length(matching_rows) > 0) {
          # Use JavaScript to highlight the row without re-rendering the table
          row_index <- matching_rows[1] - 1  # Convert to 0-based index for JavaScript
          
          session$sendCustomMessage(
            type = 'highlightTableRow',
            message = list(tableId = 'selectedOutliersTable', rowIndex = row_index)
          )
        }
      }
    } else {
      # Clear any existing highlights
      session$sendCustomMessage(
        type = 'clearTableHighlight',
        message = list(tableId = 'selectedOutliersTable')
      )
    }
  }
})

# Handle plot unhover events
observeEvent(event_data("plotly_unhover"), {
  # Clear any existing highlights
  session$sendCustomMessage(
    type = 'clearTableHighlight',
    message = list(tableId = 'selectedOutliersTable')
  )
})

# Export rotations to CSV
output$export_outliers <- downloadHandler(
  filename = function() {
    paste("outliers-", Sys.Date(), ".csv", sep="")
  },
  content = function(file) {
    write.csv(selected_outliers(), file, row.names = FALSE)
  }
)

# Observer to overwrite outliers in allGaitParams
observeEvent(input$overwrite_outliers, {
  outliers_data <- selected_outliers()
  
  # Reset all outlier steps to FALSE
  allGaitParams$outlierSteps <<- FALSE
  if (!"heelStrikeBad" %in% colnames(allGaitParams)) {
    allGaitParams$heelStrikeBad <<- FALSE
  } else {
    allGaitParams$heelStrikeBad <<- FALSE
  }
  
  if (nrow(outliers_data) > 0) {
    # Split by action for efficiency
    outlier_kill <- outliers_data[outliers_data$action == "KILL", ]
    outlier_keep <- outliers_data[outliers_data$action == "KEEP", ]

    # Helper to mark rows function
    mark_rows <- function(df_in, target_col) {
      if (nrow(df_in) == 0) return()
      library(data.table)
      time_precision <- min(0.001, input$outlier_threshold / 10)
      gait_dt <- data.table(
        participant = allGaitParams$participant,
        trialNum    = allGaitParams$trialNum,
        time_round  = round(allGaitParams$time / time_precision) * time_precision,
        row_index   = seq_len(nrow(allGaitParams))
      )
      out_dt <- data.table(
        participant = df_in$participant,
        trialNum    = df_in$trialNum,
        time_round  = round(df_in$time / time_precision) * time_precision
      )
      setkey(gait_dt, participant, trialNum, time_round)
      setkey(out_dt , participant, trialNum, time_round)
      threshold_bins <- ceiling(input$outlier_threshold / time_precision)
      matched <- c()
      for (b in -threshold_bins:threshold_bins) {
        tmp <- copy(out_dt)
        tmp[, time_round := time_round + b * time_precision]
        setkey(tmp, participant, trialNum, time_round)
        m <- gait_dt[tmp, nomatch = 0L]
        if (nrow(m) > 0) matched <- c(matched, m$row_index)
      }
      matched <- unique(matched)
      if (length(matched)) {
        allGaitParams[[target_col]][matched] <<- TRUE
      }
    }

    mark_rows(outlier_kill, "outlierSteps")
    mark_rows(outlier_keep, "heelStrikeBad")
  }
  
  # Increment the trigger to force an update of filteredGaitParams
  refresh_trigger(refresh_trigger() + 1)
  
  showNotification("Outliers overwritten", type = "message")
})

# Handle multiple point selection
observeEvent(input$confirm_selection, {
        selected_data <- event_data("plotly_selected", source = "outlier_plot")
  
  if (!is.null(selected_data)) {
    current_participant <- input$participant
    current_trial <- as.numeric(input$trialNum)
    
    # Find the closest heel strikes for all selected points
    params <- filteredParams()
    if (!validate_data_for_outliers(params, show_notifications = FALSE)) {
      return()
    }
    
    # Filter data once for efficiency
    trial_data <- safe_filter_data(params, current_participant, current_trial, "multiple_selection")
    if (nrow(trial_data) == 0) {
      return()
    }
    
    new_outliers <- lapply(seq_len(nrow(selected_data)), function(i) {
      clicked_time <- selected_data$x[i]
      
      closest_step <- tryCatch({
        trial_data %>%
          mutate(time_diff = abs(time - clicked_time)) %>%
          arrange(time_diff) %>%
          slice(1)
      }, error = function(e) {
        warning("Error processing selection data: ", e$message)
        return(data.frame())
      })
      
      if (nrow(closest_step) > 0 && closest_step$time_diff <= 0.25) {
        data.frame(
          participant = closest_step$participant,
          trialNum = closest_step$trialNum,
          time = closest_step$time,
          stringsAsFactors = FALSE
        )
      } else {
        NULL
      }
    })
    
    new_outliers <- do.call(rbind, new_outliers)
    
    if (!is.null(new_outliers) && nrow(new_outliers) > 0) {
      current_outliers <- selected_outliers()
      updated_outliers <- rbind(current_outliers, new_outliers)
      updated_outliers <- unique(updated_outliers)  # Remove any duplicates
      selected_outliers(updated_outliers)
      showNotification(paste(nrow(new_outliers), "outlier(s) added"), type = "message")
      refresh_trigger(refresh_trigger() + 1)
    }
  }
})

output$save_rds <- downloadHandler(
  filename = function() {
    file.path(dataExtraFolder, paste("allGaitParams-", Sys.Date(), ".rds", sep=""))
  },
  content = function(file) {
    saveRDS(allGaitParams, file)
  }
)
  

# Modify the reactive timer to use the user-defined interval
autoSaveTimer <- reactiveTimer(1000 * 60 * 5)  # Default to 5 minutes

# Observe changes to the autosave interval
observeEvent(input$autosave_interval, {
  invalidateLater(1000 * 60 * input$autosave_interval)
})

# Modify the autosave observer
observe({
  # Only proceed if autosave is enabled
  req(input$do_autosave)
  
  # Trigger the timer
  autoSaveTimer()
  
  isolate({
    # Get the current outliers data
    outliers_data <- selected_outliers()
  })
  
  # Generate a filename with timestamp
  filename <- paste0("outliers_autosave_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".csv")
  
  # Define the full path for the file
  filepath <- file.path(dataExtraFolder, filename)
  
  # Write the CSV file
  write.csv(outliers_data, filepath, row.names = FALSE)
  
  # Show a notification
  showNotification(paste("Outliers auto-saved to", filename), type = "message", duration = 5)
  
  # Schedule the next autosave
  invalidateLater(1000 * 60 * input$autosave_interval)
})
```