### Options
```{r,echo=FALSE}
# Data mode selection
selectizeInput("dataMode", "Data Mode",
  choices = list(
    "Steps" = "steps",
    "Trials" = "trials"
  ),
  selected = "steps",
  multiple = FALSE
)

# Variable selection inputs
selectizeInput("xscatter", "xscatter",
  choices = NULL, selected = NULL, multiple = FALSE
)
selectizeInput("yscatter", "yscatter",
  choices = NULL, selected = NULL, multiple = FALSE
)

# Grouping input
selectizeInput("groupScatter", "Group by",
  choices = NULL, selected = NULL, multiple = FALSE
)

# Interactive plot toggle
checkboxInput("useInteractivePlot", "Use interactive plot (zoom, pan, hover)", value = FALSE)

# Conditional options for trial data mode
conditionalPanel(
  condition = "input.dataMode == 'trials'",
  checkboxInput("averageData_trial", "Average data across condition", value = FALSE),
  checkboxInput("diffData_trial", "Calculate difference + means per participant", value = FALSE)
)
```

Column
--------------------------------------------

### Scatterplot  {data-height=1500}
Create scatterplots of the individual steps or summarized trial data.

```{r}
# Show static plot when interactive is not selected
conditionalPanel(
  condition = "!input.useInteractivePlot",
  imageOutput("scatter_plot")
)
```

```{r}
# Show interactive plot when interactive is selected
conditionalPanel(
  condition = "input.useInteractivePlot",
  plotlyOutput("scatter_plot_interactive")
)
```

```{r, context="server"}
# Function to get the appropriate data based on mode
get_scatter_data <- reactive({
  if (input$dataMode == "trials") {
    # Use trial data (summarized)
    data <- get_mu_dyn_long()
    if (input$averageData_trial) {
      data <- gait$summarize_across_conditions(data)
    }
    return(data)
  } else {
    # Use individual step data
    return(filteredParams())
  }
})

# Function to get appropriate column filter based on mode
get_column_filter <- function() {
  if (input$dataMode == "trials") {
    # For trial data, exclude heelStrikes and toeOffs patterns
    return(function(x) is.numeric(x) && !grepl("heelStrikes\\.|toeOffs\\.", x))
  } else {
    # For step data, use all numeric columns
    return(is.numeric)
  }
}

# Function to get default choices based on mode
get_default_choices <- function(axis) {
  if (input$dataMode == "trials") {
    if (axis == "x") {
      return(list(default = "task_max_q", fallback = c("stepWidths.sd", "stepLengths.sd")))
    } else {
      return(list(default = "task_max_e", fallback = c("stepLengths.sd", "stepWidths.sd")))
    }
  } else {
    # For step data, use first available numeric column
    return(list(default = NULL, fallback = NULL))
  }
}

# Create dynamic observers for variable selection
create_dynamic_variable_observer(
  data_reactive = get_scatter_data,
  input_id = "xscatter",
  column_filter = get_column_filter(),
  exclude_patterns = if (input$dataMode == "trials") c("heelStrikes\\.", "toeOffs\\.") else NULL,
  default_choice = get_default_choices("x")$default,
  fallback_choices = get_default_choices("x")$fallback,
  multiple = FALSE,
  input = input
)

create_dynamic_variable_observer(
  data_reactive = get_scatter_data,
  input_id = "yscatter",
  column_filter = get_column_filter(),
  exclude_patterns = if (input$dataMode == "trials") c("heelStrikes\\.", "toeOffs\\.") else NULL,
  default_choice = get_default_choices("y")$default,
  fallback_choices = get_default_choices("y")$fallback,
  multiple = FALSE,
  input = input
)

# Create dynamic observer for category selection
create_dynamic_category_observer(
  data_reactive = get_scatter_data,
  input_id = "groupScatter",
  category_choices = categoriesExtraInputs,
  default_selection = if (input$dataMode == "trials") "participant" else categoriesExtraInputs[1],
  multiple = FALSE,
  input = input
)

# Create reactive expression for the plot data
get_plot_data <- reactive({
  # Wait for inputs to be initialized
  req(input$dataMode, input$xscatter, input$yscatter, input$groupScatter)
  
  data <- get_scatter_data()
  group_var <- input$groupScatter
  x_var <- input$xscatter
  y_var <- input$yscatter
  
  # Validate inputs
  if (is.null(data) || nrow(data) == 0) {
    return(list(error = "No data available for plotting"))
  }
  
  if (is.null(x_var) || is.null(y_var) || is.null(group_var)) {
    return(list(error = "Please select variables for plotting"))
  }
  
  return(list(
    data = data,
    group_var = group_var,
    x_var = x_var,
    y_var = y_var
  ))
})

# Render the static scatterplot
output$scatter_plot <- renderSVG({ 
  reactive({
    plot_data <- get_plot_data()
    
    # Check for errors
    if (!is.null(plot_data$error)) {
      return(plotting$create_error_plot(plot_data$error))
    }
    
    # Create the plot (with marginal plots for static version)
    plotting$make_scatter_plot_steps(
      plot_data$data, 
      plot_data$group_var, 
      plot_data$x_var, 
      plot_data$y_var, 
      show_legend = TRUE, 
      baseSize = input$baseSize
    )
  })
})

# Render the interactive scatterplot
output$scatter_plot_interactive <- renderPlotly({
  plot_data <- get_plot_data()
  
  # Check for errors
  if (!is.null(plot_data$error)) {
    return(plot_ly() %>% add_annotations(text = plot_data$error, showarrow = FALSE))
  }
  
  # Create simple hover text
  plot_data$data$hover_text <- paste0(
    plot_data$x_var, ": ", round(plot_data$data[[plot_data$x_var]], 3), "<br>",
    plot_data$y_var, ": ", round(plot_data$data[[plot_data$y_var]], 3)
  )
  
  # Create the base ggplot with simple hover text
  if (plot_data$group_var == "None") {
    p <- ggplot(plot_data$data, aes_string(x = plot_data$x_var, y = plot_data$y_var, text = "hover_text")) +
      geom_point(alpha = 0.5, size = input$baseSize / 4) +
      theme_minimal(base_size = input$baseSize)
  } else {
    p <- ggplot(plot_data$data, aes_string(x = plot_data$x_var, y = plot_data$y_var, col = plot_data$group_var, text = "hover_text")) +
      geom_point(alpha = 0.5, size = input$baseSize / 4) +
      theme_minimal(base_size = input$baseSize)
  }
  
  # Add equal coordinates if both axes contain "pos"
  x_contains_pos <- grepl("pos", plot_data$x_var, ignore.case = TRUE)
  y_contains_pos <- grepl("pos", plot_data$y_var, ignore.case = TRUE)
  if (x_contains_pos && y_contains_pos) {
    p <- p + coord_equal()
  }
  
  # Convert to plotly
  ggplotly(p, tooltip = "text")
})
```