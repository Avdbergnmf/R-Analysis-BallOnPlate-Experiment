### Options

```{r}
selectizeInput("psTracker", "Tracker",
  choices = trackers, selected = "udp", multiple = FALSE
)

selectizeInput("psVar", "Variable (continuous data)",
  choices = NULL, selected = NULL, multiple = FALSE
)

numericInput("psMaxFreq", "Maximum frequency (Hz)",
  min = 0.5, max = 15, value = 2.5, step = 0.5
)


# Caching controls
div(
  actionButton("psUpdateTrackerData", "Update Power Spectrum Data",
    class = "btn-primary", style = "margin-bottom: 10px;"
  ),
  div(id = "psTrackerStatus", style = "margin-top: 5px; font-size: 12px; color: #666;")
)

selectizeInput("psGroup", "Group by",
  choices = NULL, selected = NULL, multiple = FALSE
)

selectizeInput("psSplit", "Split by",
  choices = NULL, selected = NULL, multiple = FALSE
)

checkboxInput("psStack", "Stack power spectra",
  value = TRUE
)

checkboxInput("psEnablePlotting", "Enable power spectrum plotting",
  value = FALSE
)

```

```{r}
bsTooltip("psTracker",
  "Select which tracker data to analyze (e.g., hip, pelvis, etc.)",
  placement = "right",
  trigger = "hover"
)
bsTooltip("psVar",
  "Select a continuous variable to compute power spectrum. Works best with position/velocity data.",
  placement = "right",
  trigger = "hover"
)
bsTooltip("psMaxFreq",
  "Maximum frequency to display. Use 2.5 Hz for gait-related movements, higher for faster dynamics.",
  placement = "right",
  trigger = "hover"
)
bsTooltip("psStack",
  "When checked, stacks power spectra on top of each other (area chart). When unchecked, shows overlapping lines.",
  placement = "right",
  trigger = "hover"
)
```

Column
--------------------------------------------

### Power Spectrum  {data-height=1500}
Visualize frequency content of continuous data using power spectral density analysis.
```{r}
plotOutput("powerSpectrumPlot", height = "auto")
```


```{r, context="server"}
# Source power spectrum utilities and caching system
source("source/power_spectrum_utils.R", local = TRUE)
source("source/data_caching_utils.R", local = TRUE)

# Create power spectrum data cache manager
ps_cache_manager <- create_data_cache_manager("power_spectrum")

# Define functions for the power spectrum caching system
load_power_spectrum_data <- function(participant, trial) {
  # Load raw tracker data first
  data <- get_t_data(participant, input$psTracker, trial)
  if (is.null(data) || nrow(data) == 0) {
    return(data.frame())
  }
  
  # Check if we have the required variable
  if (!input$psVar %in% names(data)) {
    return(data.frame())
  }
  
  # Compute power spectrum for this participant-trial combination
  tryCatch({
    # Clean data
    valid_mask <- is.finite(data[[input$psVar]]) & is.finite(data$time)
    values <- data[[input$psVar]][valid_mask]
    times <- data$time[valid_mask]
    
    if (length(values) < 50) {
      return(data.frame())
    }
    
    # Calculate sampling frequency
    if (length(times) > 1) {
      dt <- median(diff(times), na.rm = TRUE)
      fs <- if (is.finite(dt) && dt > 0) 1 / dt else 120
    } else {
      fs <- 120  # Default
    }
    
    # Compute PSD
    psd_df <- compute_single_psd(
      values,
      fs = fs,
      max_freq = input$psMaxFreq,
      normalize = TRUE
    )
    
    if (is.null(psd_df)) {
      return(data.frame())
    }
    
    
    # Add metadata
    psd_df$participant <- participant
    psd_df$trialNum <- as.numeric(as.character(trial))
    
    return(psd_df)
  }, error = function(e) {
    warning(sprintf("Error computing power spectrum for participant %s, trial %s: %s", 
                   participant, trial, e$message))
    return(data.frame())
  })
}

get_ps_filters <- function() {
  # Check if required inputs exist
  if (any(is.null(input$filterParticipants), is.null(input$filterTrials), 
          is.null(input$psTracker), is.null(input$psVar))) {
    return(NULL)
  }
  
  # Pre-filter participants by condition if specified
  filtered_participants <- input$filterParticipants
  if (!is.null(input$filterCondition) && length(input$filterCondition) > 0) {
    # Get participants that match any of the selected conditions
    condition_participants <- c()
    for (participant in input$filterParticipants) {
      if (condition_number(participant) %in% input$filterCondition) {
        condition_participants <- c(condition_participants, participant)
      }
    }
    filtered_participants <- condition_participants
  }
  
  # Get current filter state including power spectrum parameters
  list(
    participants = filtered_participants,
    trials = input$filterTrials,
    tracker = input$psTracker,
    variable = input$psVar,
    max_freq = input$psMaxFreq
  )
}

has_ps_data <- function(participant, trial) {
  # Check if tracker data exists for this participant-trial combination
  data <- get_t_data(participant, input$psTracker, trial)
  return(!is.null(data) && nrow(data) > 0 && input$psVar %in% names(data))
}

# Create cached power spectrum data reactive
cachedPowerSpectrumData <- create_cached_data_reactive(
  cache_manager = ps_cache_manager,
  load_function = load_power_spectrum_data,
  filter_function = get_ps_filters,
  validate_function = has_ps_data,
  cache_name = "power spectrum"
)

# Helper function to add grouping variables to cached PSD data
add_grouping_to_psd_data <- function(cached_ps_data, group_by, split_by) {
  if (is.null(cached_ps_data) || nrow(cached_ps_data) == 0) {
    return(NULL)
  }
  
  # Get grouping information from get_mu_dyn_long
  mu_data <- get_mu_dyn_long()
  if (is.null(mu_data) || nrow(mu_data) == 0) {
    return(NULL)
  }
  
  # Ensure both datasets have compatible trialNum types
  cached_ps_data$trialNum <- as.numeric(as.character(cached_ps_data$trialNum))
  mu_data$trialNum <- as.numeric(as.character(mu_data$trialNum))
  
  # Add grouping information to power spectrum data
  grouping_vars <- c("participant", "trialNum")
  if (!is.null(group_by) && group_by != "None") {
    grouping_vars <- c(grouping_vars, group_by)
  }
  if (!is.null(split_by) && split_by != "None") {
    grouping_vars <- c(grouping_vars, split_by)
  }
  
  ps_data <- cached_ps_data %>%
    dplyr::left_join(
      mu_data %>% dplyr::select(dplyr::all_of(grouping_vars)),
      by = c("participant", "trialNum")
    )
  
  # Check if join worked - if all grouping columns are NA, something went wrong
  if (!is.null(group_by) && group_by != "None" && group_by %in% names(ps_data)) {
    if (all(is.na(ps_data[[group_by]]))) {
      warning(sprintf("No matching data found for grouping variable '%s'. Check if participant/trial combinations exist in both datasets.", group_by))
    }
  }
  
  return(ps_data)
}

# Update variable choices when tracker changes (similar to page3_rawTrackerData.Rmd)
observe({
  if (!is.null(input$psTracker)) {
    # Use trial 7, participant 1 to get example data (as suggested)
    choices <- getOptions(input$psTracker, 7)
    
    # Get current selection
    current_selection <- isolate(input$psVar)
    
    # Default to "PelvisPos" if available, otherwise first available choice
    default_var <- if (length(choices) > 0 && !"data not available" %in% choices) {
      if ("PelvisPos" %in% choices) {
        "PelvisPos"
      } else {
        choices[1]
      }
    } else {
      NULL
    }
    
    updateSelectizeInput(session, "psVar",
      choices = choices,
      selected = if (!is.null(current_selection) && current_selection %in% choices) {
        current_selection
      } else {
        default_var
      }
    )
  }
})

# Use create_dynamic_category_observer for group and split selection
# These use get_mu_dyn_long for category options, not the cached tracker data
create_dynamic_category_observer(
  data_reactive = get_mu_dyn_long,
  input_id = "psGroup",
  category_choices = categoriesExtraInputs,
  default_selection = "participant",
  multiple = FALSE,
  input = input
)

create_dynamic_category_observer(
  data_reactive = get_mu_dyn_long,
  input_id = "psSplit",
  category_choices = c("None", categoriesExtraInputs),
  default_selection = "condition",
  multiple = FALSE,
  input = input
)

# Trigger power spectrum data update when button is clicked
observeEvent(input$psUpdateTrackerData, {
  # Flag that power spectrum data should be (re)loaded
  ps_cache_manager$request_data()
  # Bump the reactive trigger so all downstream reactives recompute
  refresh_trigger(refresh_trigger() + 1)
})


# Reset cache when switching trackers, variables, or computation parameters
observeEvent({
  input$psTracker
  input$psVar
  input$psMaxFreq
}, {
  # Reset cache when computation parameters change
  ps_cache_manager$reset_data()
}, ignoreNULL = TRUE, ignoreInit = TRUE)

# Status display for power spectrum data
output$psTrackerStatus <- renderText({
  data <- cachedPowerSpectrumData()
  if (nrow(data) > 0) {
    sprintf(
      "Ready: %d participants, %d trials, %d frequency points",
      length(unique(data$participant)),
      length(unique(data$trialNum)),
      nrow(data)
    )
  } else {
    "No power spectrum data loaded. Click 'Update Tracker Data' to compute power spectra for the selected participants/trials."
  }
})


# Compute power spectrum height based on split
psPlotCount <- reactive({
  if (is.null(input$psSplit) || input$psSplit == "None" || input$psSplit == "") {
    return(1)
  }
  # Use get_mu_dyn_long for split count (has all the category columns)
  data <- get_mu_dyn_long()
  if (is.null(data) || nrow(data) == 0 || !input$psSplit %in% colnames(data)) {
    return(1)
  }
  return(length(unique(data[[input$psSplit]])))
})

psPlotHeight <- reactive({
  base_height <- max(500, input$plotheight)
  if (is.null(input$psSplit) || input$psSplit == "None") {
    return(base_height)
  } else {
    return(base_height * psPlotCount())
  }
})

# Main power spectrum plot
output$powerSpectrumPlot <- renderPlot({
  # Check if plotting is enabled
  if (!input$psEnablePlotting) {
    return(ggplot() +
      annotate("text",
        x = 0.5, y = 0.5,
        label = "Enable power spectrum plotting using the checkbox above",
        hjust = 0.5, vjust = 0.5, size = 4, color = "blue"
      ) +
      xlim(0, 1) +
      ylim(0, 1) +
      theme_void() +
      ggtitle("Power Spectrum Plotting Disabled"))
  }
  
  req(input$psTracker, input$psVar, input$psGroup)
  
  # Use cached power spectrum data
  cached_ps_data <- cachedPowerSpectrumData()
  
  # Check if we have cached power spectrum data
  if (nrow(cached_ps_data) == 0) {
    return(ggplot() +
      annotate("text",
        x = 0.5, y = 0.5,
        label = "No power spectrum data loaded. Please click 'Update Tracker Data' to compute power spectra for the selected participants/trials.",
        hjust = 0.5, vjust = 0.5, size = 4, color = "red"
      ) +
      xlim(0, 1) +
      ylim(0, 1) +
      theme_void() +
      ggtitle("No Power Spectrum Data Loaded"))
  }
  
  # Process cached power spectrum data for plotting
  tryCatch({
    # Add grouping variables to cached PSD data
    ps_data <- add_grouping_to_psd_data(
      cached_ps_data, 
      input$psGroup, 
      if (input$psSplit == "None") NULL else input$psSplit
    )
    
    if (is.null(ps_data) || nrow(ps_data) == 0) {
      return(ggplot() +
        annotate("text",
          x = 0.5, y = 0.5,
          label = "Could not add grouping variables to power spectrum data.",
          hjust = 0.5, vjust = 0.5, size = 3, color = "red"
        ) +
        xlim(0, 1) +
        ylim(0, 1) +
        theme_void() +
        ggtitle("Grouping Failed"))
    }
    
    
    # Sum across participant/trial to get group-level spectra for plotting
    # Don't group by frequency - instead interpolate to a common frequency grid first
    group_vars <- c()
    if (!is.null(input$psGroup) && input$psGroup != "None" && input$psGroup %in% names(ps_data)) {
      group_vars <- c(group_vars, input$psGroup)
    }
    if (!is.null(input$psSplit) && input$psSplit != "None" && input$psSplit %in% names(ps_data)) {
      group_vars <- c(group_vars, input$psSplit)
    }
    
    if (length(group_vars) > 0) {
      # Create a common frequency grid
      freq_range <- range(ps_data$frequency)
      common_freqs <- seq(freq_range[1], freq_range[2], length.out = 500)  # Smooth frequency grid
      
      # Interpolate each participant-trial to common grid, then sum
      ps_data <- ps_data %>%
        dplyr::group_by(participant, trialNum, dplyr::across(dplyr::all_of(group_vars))) %>%
        dplyr::group_modify(~ {
          if (nrow(.x) > 1) {
            # Interpolate to common frequency grid
            interp_power <- approx(.x$frequency, .x$power, xout = common_freqs, rule = 2)$y
            data.frame(frequency = common_freqs, power = interp_power)
          } else {
            .x
          }
        }) %>%
        dplyr::ungroup() %>%
        dplyr::group_by(frequency, dplyr::across(dplyr::all_of(group_vars))) %>%
        dplyr::summarize(
          power = sum(power, na.rm = TRUE),
          .groups = "drop"
        )
    } else {
      # No grouping - just interpolate to common grid and sum
      freq_range <- range(ps_data$frequency)
      common_freqs <- seq(freq_range[1], freq_range[2], length.out = 200)
      
      ps_data <- ps_data %>%
        dplyr::group_by(participant, trialNum) %>%
        dplyr::group_modify(~ {
          if (nrow(.x) > 1) {
            interp_power <- approx(.x$frequency, .x$power, xout = common_freqs, rule = 2)$y
            data.frame(frequency = common_freqs, power = interp_power)
          } else {
            .x
          }
        }) %>%
        dplyr::ungroup() %>%
        dplyr::group_by(frequency) %>%
        dplyr::summarize(
          power = sum(power, na.rm = TRUE),
          .groups = "drop"
        )
    }
    
    # Create the power spectrum plot
    plot_power_spectrum(
      ps_data = ps_data,
      stack = input$psStack,
      split_by = if (input$psSplit == "None") NULL else input$psSplit,
      base_size = input$baseSize*2
    )
    
  }, error = function(e) {
    ggplot() +
      annotate("text",
        x = 0.5, y = 0.5,
        label = paste("Error computing power spectrum:", e$message),
        hjust = 0.5, vjust = 0.5, size = 3, color = "red"
      ) +
      xlim(0, 1) +
      ylim(0, 1) +
      theme_void() +
      ggtitle("Error")
  })
}, height = psPlotHeight)

```

