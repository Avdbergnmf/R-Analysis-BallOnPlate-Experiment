### Options

```{r}
# Data type selection
selectizeInput("dataType", "Data Type",
  choices = c("Gait Data" = "gait", "Simulation Data" = "simulation"),
  selected = "gait", multiple = FALSE
)

# Status display and controls for simulation data
conditionalPanel(
  condition = "input.dataType == 'simulation'",
  div(
    actionButton("simUpdateData", "Update Simulation Data",
      class = "btn-primary", style = "margin-bottom: 10px;"
    ),
    div(id = "simulationStatus", style = "margin-top: 5px; font-size: 12px; color: #666;"),
    div(
      style = "margin-top: 5px; font-size: 11px; color: #888;",
      "Note: Click 'Update Simulation Data' to load and cache simulation data."
    )
  )
)

selectizeInput("plot", "Plot",
  choices = NULL, selected = NULL, multiple = FALSE
)
selectizeInput("group", "Group by",
  choices = NULL, selected = NULL, multiple = FALSE
)
selectizeInput("position", "Bar positions",
  choices = c("stack", "identity", "dodge"), selected = "identity", multiple = FALSE
)
selectizeInput("split", "Split by",
  choices = NULL, selected = NULL, multiple = FALSE
)
# checkboxInput("means", "Show means",
#  value = TRUE
# )

numericInput("bin", "Bin width",
  min = 0.001, max = 0.5, value = 0.01, step = 0.01
)

checkboxInput("enableHistograms", "Enable histogram plotting",
  value = FALSE
)

checkboxInput("interactiveHist", "Interactive histograms (hover tooltips)",
  value = FALSE
)

checkboxInput("useSummarizedData", "Use summarized data (means per participant/trial)",
  value = FALSE
)
# Additional checkbox for summarizing across conditions
conditionalPanel(
  condition = "input.useSummarizedData == true",
  checkboxInput("summarizeAcrossConditions", "Also summarize across conditions (means per participant only)",
    value = FALSE
  )
)

# Show simulation-specific filter only when simulation data type is selected
conditionalPanel(
  condition = "input.dataType == 'simulation'",
  checkboxInput(
    "sim_only_on_plate",
    "Only samples when ball is on the plate",
    value = TRUE
  )
)
```

Column
--------------------------------------------

### Histograms  {data-height=1500}
Create histograms of the step results of the selected data.
```{r}
tagList(
  conditionalPanel(condition = "!input.interactiveHist", imageOutput("hist")),
  conditionalPanel(condition = "input.interactiveHist", plotlyOutput("hist_plotly"))
)
```

### Mean values


```{r}
tableOutput("splitMeanTable")
tableOutput("overallMeanTable")
```



```{r, context="server"}
# Source caching system
source("source/data_caching_setup.R", local = TRUE)
source("source/data_caching_system.R", local = TRUE)

# Create simulation data cache manager
sim_cache_manager <- create_shiny_cache_manager("simulation")

# Create cached simulation data reactive using the new system
cachedSimulationData <- create_shiny_cached_data_reactive(
  cache_manager = sim_cache_manager,
  data_type = "simulation"
)

# Reactive data source based on data type selection
currentData <- reactive({
  if (input$useSummarizedData) {
    # Use summarized data when checkbox is checked
    summarized_data <- get_mu_dyn_long()
    # Apply additional summarization across conditions if requested
    if (input$summarizeAcrossConditions) {
      summarized_data <- summarize_across_conditions(summarized_data)
    }
    return(summarized_data)
  } else {
    # Use full data when checkbox is unchecked
    if (input$dataType == "simulation") {
      # Use cached simulation data
      sim_data <- cachedSimulationData()
      
      if (nrow(sim_data) > 0) {
        # Optionally filter to only samples where the ball is on the plate
        if (!is.null(input$sim_only_on_plate) && input$sim_only_on_plate &&
          ("simulating" %in% colnames(sim_data))) {
          sim_data <- sim_data[sim_data$simulating == TRUE, , drop = FALSE]
        }
        return(sim_data)
      }
      
      # Return empty data frame with expected structure if no data available
      return(data.frame(
        participant = character(0),
        trialNum = numeric(0),
        condition = character(0),
        phase = character(0)
      ))
    } else {
      # Use regular gait data
      return(filteredParams())
    }
  }
})

# Custom observer for variable selection that handles both gait and simulation data
observe({
  data <- currentData()

  if (is.null(data) || nrow(data) == 0) {
    updateSelectizeInput(session, "plot", choices = character(0), selected = NULL)
    return()
  }

  # Get all column names from the data
  available_vars <- names(data)

  # Get current selection
  current_selection <- isolate(input$plot)

  # Update the input
  update_selectize_smart(
    session, "plot", available_vars, current_selection
  )
})

# Use create_dynamic_category_observer for group selection
create_dynamic_category_observer(
  data_reactive = currentData,
  input_id = "group",
  category_choices = if (input$dataType == "simulation") {
    c("participant", "condition", "trialNum", "phase", "arcDeg")
  } else {
    categoriesExtraInputs
  },
  default_selection = "participant",
  multiple = FALSE,
  input = input
)

# Use create_dynamic_category_observer for split selection
create_dynamic_category_observer(
  data_reactive = currentData,
  input_id = "split",
  category_choices = c("None", if (input$dataType == "simulation") {
    c("participant", "condition", "trialNum", "phase", "arcDeg")
  } else {
    categoriesExtraInputs
  }),
  default_selection = "None",
  multiple = FALSE,
  input = input
)

# Trigger simulation data update when button is clicked
observeEvent(input$simUpdateData, {
  # Flag that simulation data should be (re)loaded
  sim_cache_manager$request_data()
})

# Status display for simulation data
output$simulationStatus <- renderText({
  if (input$dataType == "simulation") {
    # Get current cached simulation data
    data <- cachedSimulationData()
    if (nrow(data) > 0) {
      sprintf(
        "Ready: %d participants, %d trials, %d samples",
        length(unique(data$participant)),
        length(unique(data$trialNum)),
        nrow(data)
      )
    } else {
      "No simulation data loaded. Click 'Update Simulation Data' to load simulation data for the selected participants/trials."
    }
  } else {
    ""
  }
})

plotCount <- reactive({
  colName <- as.character(input$split)
  if (colName == "None" || colName == "") {
    return(1)
  }
  data <- currentData()
  if (nrow(data) == 0 || !colName %in% colnames(data)) {
    return(1)
  }
  return(length(unique(data[[colName]])))
})

plotHeight <- reactive({
  if (input$split == "None") {
    return(input$plotheight)
  } else {
    return(input$plotheight * plotCount())
  }
})

output$hist <- renderSVG({
  reactive({
    # Check if histogram plotting is enabled
    if (!input$enableHistograms) {
      return(ggplot() +
        annotate("text",
          x = 0.5, y = 0.5,
          label = "Enable histogram plotting using the checkbox above",
          hjust = 0.5, vjust = 0.5, size = 4, color = "blue"
        ) +
        xlim(0, 1) +
        ylim(0, 1) +
        theme_void() +
        ggtitle("Histogram Plotting Disabled"))
    }

    # Use current data source
    data <- currentData()

    # Check if we have data
    if (nrow(data) == 0) {
      # Create empty plot with message
      message <- if (input$dataType == "simulation") {
        "No simulation data available. Please check your filters and ensure participants/trials are selected."
      } else {
        "No data available for the selected filters and data type"
      }
      ggplot() +
        annotate("text",
          x = 0.5, y = 0.5,
          label = message,
          hjust = 0.5, vjust = 0.5, size = 4, color = "red"
        ) +
        xlim(0, 1) +
        ylim(0, 1) +
        theme_void() +
        ggtitle("No Data Available")
    } else {
      # Create histogram with available data
      # When using summarized data, pass the same data as both parameters
      mu_data <- if (input$useSummarizedData) data else get_mu_dyn_long()
      make_histogram(data, mu_data, FALSE, input$group, input$split, input$plot, input$bin, input$position, baseSize = input$baseSize)
    }
  })
})

# Interactive histogram (Plotly)
output$hist_plotly <- renderPlotly({
  # Check if histogram plotting is enabled
  if (!input$enableHistograms) {
    p <- ggplot() +
      annotate("text",
        x = 0.5, y = 0.5,
        label = "Enable histogram plotting using the checkbox above",
        hjust = 0.5, vjust = 0.5, size = 4, color = "blue"
      ) +
      xlim(0, 1) +
      ylim(0, 1) +
      theme_void() +
      ggtitle("Histogram Plotting Disabled")
    return(ggplotly(p, dynamicTicks = TRUE, height = plotHeight()))
  }

  # Use current data source
  data <- currentData()

  # Check if we have data
  if (nrow(data) == 0) {
    message <- if (input$dataType == "simulation") {
      "No simulation data available. Please check your filters and ensure participants/trials are selected."
    } else {
      "No data available for the selected filters and data type"
    }
    p <- ggplot() +
      annotate("text",
        x = 0.5, y = 0.5,
        label = message,
        hjust = 0.5, vjust = 0.5, size = 4, color = "red"
      ) +
      xlim(0, 1) +
      ylim(0, 1) +
      theme_void() +
      ggtitle("No Data Available")
    return(ggplotly(p, dynamicTicks = TRUE, height = plotHeight()))
  }

  # Create histogram with available data and convert to Plotly
  # When using summarized data, pass the same data as both parameters
  mu_data <- if (input$useSummarizedData) data else get_mu_dyn_long()
  p <- make_histogram(data, mu_data, FALSE, input$group, input$split, input$plot, input$bin, input$position, baseSize = input$baseSize)
  ggplotly(p, tooltip = "all", dynamicTicks = TRUE, height = plotHeight())
})

# Add mean tables
output$splitMeanTable <- renderTable({
  # Only render when histograms are enabled
  if (!input$enableHistograms) {
    return(NULL)
  }

  req(input$plot, input$split)
  data <- currentData()
  if (nrow(data) == 0) {
    return(NULL)
  }

  plotVar <- input$plot
  splitVar <- input$split
  if (splitVar != "None" && splitVar %in% colnames(data)) {
    aggregate(data[[plotVar]], by = list(data[[splitVar]]), FUN = mean, na.rm = TRUE)
  }
})

output$overallMeanTable <- renderTable({
  # Only render when histograms are enabled
  if (!input$enableHistograms) {
    return(NULL)
  }

  req(input$plot)
  data <- currentData()
  if (nrow(data) == 0) {
    return(NULL)
  }

  plotVar <- input$plot
  if (plotVar %in% colnames(data)) {
    overallMean <- mean(data[[plotVar]], na.rm = TRUE)
    overallSD <- sd(data[[plotVar]], na.rm = TRUE)
    data.frame(Statistic = c("Mean", "SD"), Value = c(overallMean, overallSD))
  }
})
```

