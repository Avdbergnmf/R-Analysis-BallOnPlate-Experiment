### Options

```{r}
# Data type selection
selectizeInput("dataType", "Data Type",
  choices = c("Summarized Data" = "summarized", "Gait Data" = "gait", "Simulation Data" = "simulation", "Raw Tracker Data" = "raw_tracker"),
  selected = "gait", multiple = FALSE
)

# Status display and controls for simulation data
conditionalPanel(
  condition = "input.dataType == 'simulation'",
  div(
    actionButton("simUpdateData", "Update Simulation Data",
      class = "btn-primary", style = "margin-bottom: 10px;"
    ),
    div(id = "simulationStatus", style = "margin-top: 5px; font-size: 12px; color: #666;"),
    div(
      style = "margin-top: 5px; font-size: 11px; color: #888;",
      "Note: Click 'Update Simulation Data' to load and cache simulation data."
    )
  )
)

# Tracker selection and controls for raw tracker data
conditionalPanel(
  condition = "input.dataType == 'raw_tracker'",
  div(
    selectizeInput("rawTracker", "Tracker Type",
      choices = trackers, selected = trackers[2], multiple = FALSE
    ),
    actionButton("rawTrackerUpdateData", "Update Raw Tracker Data",
      class = "btn-primary", style = "margin-bottom: 10px;"
    ),
    div(id = "rawTrackerStatus", style = "margin-top: 5px; font-size: 12px; color: #666;"),
    div(
      style = "margin-top: 5px; font-size: 11px; color: #888;",
      "Note: Click 'Update Raw Tracker Data' to load and cache raw tracker data."
    )
  )
)

selectizeInput("plot", "Plot",
  choices = NULL, selected = NULL, multiple = FALSE
)
selectizeInput("group", "Group by",
  choices = NULL, selected = NULL, multiple = FALSE
)
selectizeInput("position", "Bar positions",
  choices = c("stack", "identity", "dodge"), selected = "identity", multiple = FALSE
)
selectizeInput("split", "Split by",
  choices = NULL, selected = NULL, multiple = FALSE
)
# checkboxInput("means", "Show means",
#  value = TRUE
# )

numericInput("bin", "Bin width",
  min = 0.001, max = 0.5, value = 0.01, step = 0.01
)

checkboxInput("enableHistograms", "Enable histogram plotting",
  value = FALSE
)

checkboxInput("interactiveHist", "Interactive histograms (hover tooltips)",
  value = FALSE
)

# Downsampling control for large datasets
numericInput("downsampleFactor", "Downsampling factor (1=no downsampling, 10=every 10th row)",
  min = 1, max = 100, value = 10, step = 1
)
# Additional checkbox for summarizing across conditions
conditionalPanel(
  condition = "input.dataType == 'summarized'",
  checkboxInput("summarizeAcrossConditions", "Also summarize across conditions (means per participant only)",
    value = FALSE
  )
)

# Show simulation-specific filter only when simulation data type is selected
conditionalPanel(
  condition = "input.dataType == 'simulation'",
  checkboxInput(
    "sim_only_on_plate",
    "Only samples when ball is on the plate",
    value = TRUE
  )
)
```

Column
--------------------------------------------

### Histograms  {data-height=1500}
Create histograms of the step results of the selected data.
```{r}
tagList(
  conditionalPanel(condition = "!input.interactiveHist", imageOutput("hist")),
  conditionalPanel(condition = "input.interactiveHist", plotlyOutput("hist_plotly"))
)
```

### Mean values


```{r}
tableOutput("splitMeanTable")
tableOutput("overallMeanTable")
```



```{r, context="server"}
# Source required files for data loading functions
source("source/get_simulation_data.R", local = TRUE)
source("source/data_caching_setup.R", local = TRUE)
source("source/data_caching_system.R", local = TRUE)
source("source/logging_utils.R", local = TRUE)

# Create logger for this page
page_logger <- create_module_logger("PAGE5-HISTOGRAMS")

# Define cacheable data types and their configurations
cacheable_data_types <- list(
  "simulation" = list(
    button_id = "simUpdateData",
    status_id = "simulationStatus",
    display_name = "Simulation Data"
  ),
  "raw_tracker" = list(
    button_id = "rawTrackerUpdateData", 
    status_id = "rawTrackerStatus",
    display_name = "Raw Tracker Data"
  )
)

# Create cache managers and reactive data for all cacheable data types
cache_managers <- list()
cached_data_reactive <- list()

for (data_type in names(cacheable_data_types)) {
  # Create cache manager
  cache_managers[[data_type]] <- create_shiny_cache_manager(data_type, use_parallel = FALSE)
  
  # Create cached data reactive
  cached_data_reactive[[data_type]] <- create_shiny_cached_data_reactive(
    cache_manager = cache_managers[[data_type]],
    data_type = data_type
  )
}

# Helper function to get cached data for a data type with fast cache lookup
get_cached_data_local <- function(data_type) {
  if (data_type %in% names(cache_managers)) {
    # Try fast cache first
    page_logger("DEBUG", "Trying fast cache lookup for", data_type)
    
    # Get current filters for fast cache lookup
    current_filters <- get_universal_filters()
    if (!is.null(current_filters)) {
      # Get downsampling factor from user input
      downsample_factor <- if (!is.null(input$downsampleFactor)) input$downsampleFactor else 1
      
      # Try fast cache lookup
      fast_data <- cache_managers[[data_type]]$get_fast_cache(
        participants = current_filters$participants,
        trials = current_filters$trials,
        condition_filter = current_filters$condition,
        downsample_factor = downsample_factor
      )
      
      if (!is.null(fast_data)) {
        page_logger("DEBUG", "Fast cache hit! Returning", nrow(fast_data), "rows")
        return(fast_data)
      } else {
        page_logger("DEBUG", "Fast cache miss - falling back to reactive")
      }
    }
    
    # Fallback to reactive if fast cache miss
    if (data_type %in% names(cached_data_reactive)) {
      page_logger("DEBUG", "Using reactive data for", data_type)
      return(cached_data_reactive[[data_type]]())
    }
  }
  
  page_logger("DEBUG", "No data available for", data_type)
  return(data.frame())
}

# Helper function to apply data-specific filters
apply_data_filters <- function(data, data_type) {
  if (data_type == "simulation" && nrow(data) > 0) {
    # Optionally filter to only samples where the ball is on the plate
    if (!is.null(input$sim_only_on_plate) && input$sim_only_on_plate &&
        ("simulating" %in% colnames(data))) {
      data <- data[data$simulating == TRUE, , drop = FALSE]
    }
  }
  return(data)
}

# Helper function to get empty data frame structure for a data type
get_empty_data_structure <- function(data_type) {
  base_structure <- data.frame(
    participant = character(0),
    trialNum = numeric(0),
    condition = character(0)
  )
  
  if (data_type == "simulation") {
    base_structure$phase <- character(0)
  } else if (data_type == "raw_tracker") {
    base_structure$time <- numeric(0)
  }
  
  return(base_structure)
}

# Reactive data source based on data type selection
currentData <- reactive({
  page_logger("DEBUG", "currentData reactive triggered")
  page_logger("DEBUG", "dataType:", input$dataType)
  
  if (input$dataType == "summarized") {
    # Use summarized data when "Summarized Data" is selected
    page_logger("DEBUG", "Using summarized data")
    tryCatch({
      summarized_data <- get_mu_dyn_long()
      if (is.null(summarized_data) || nrow(summarized_data) == 0) {
        page_logger("WARN", "get_mu_dyn_long returned empty data")
        return(data.frame())
      }
      page_logger("DEBUG", "Summarized data loaded:", nrow(summarized_data), "rows")
      
      # Apply additional summarization across conditions if requested
      if (input$summarizeAcrossConditions) {
        page_logger("DEBUG", "Applying additional summarization across conditions")
        summarized_data <- summarize_across_conditions(summarized_data)
        page_logger("DEBUG", "After condition summarization:", nrow(summarized_data), "rows")
      }
      return(summarized_data)
    }, error = function(e) {
      page_logger("ERROR", "Error loading summarized data:", e$message)
      page_logger("ERROR", "This usually means required data objects (allGaitParams, allQResults, etc.) are not available")
      return(data.frame())
    })
  } else if (input$dataType %in% names(cacheable_data_types)) {
    # Use cached data for cacheable data types
    page_logger("DEBUG", "Using cached data for type:", input$dataType)
    data <- get_cached_data_local(input$dataType)
    page_logger("DEBUG", "Cached data loaded:", nrow(data), "rows")
    
    if (nrow(data) > 0) {
      # Apply data-specific filters
      page_logger("DEBUG", "Applying data-specific filters")
      data <- apply_data_filters(data, input$dataType)
      page_logger("DEBUG", "After filtering:", nrow(data), "rows")
      return(data)
    }
    
    # Return empty data frame with expected structure if no data available
    page_logger("DEBUG", "No cached data available, returning empty structure")
    return(get_empty_data_structure(input$dataType))
  } else {
    # Use regular gait data for non-cacheable types
    page_logger("DEBUG", "Using regular gait data")
    gait_data <- filteredParams()
    page_logger("DEBUG", "Gait data loaded:", nrow(gait_data), "rows")
    return(gait_data)
  }
})

# Custom observer for variable selection that handles both gait and simulation data
observe({
  data <- currentData()

  if (is.null(data) || nrow(data) == 0) {
    #updateSelectizeInput(session, "plot", choices = character(0), selected = NULL)
    return()
  }

  # Get all column names from the data
  available_vars <- names(data)

  # Get current selection
  current_selection <- isolate(input$plot)

  # Update the input
  update_selectize_smart(
    session, "plot", available_vars, current_selection
  )
})

# Helper function to get category choices for a data type
get_category_choices <- function(data_type) {
  if (data_type == "simulation") {
    return(c("participant", "condition", "trialNum", "phase", "arcDeg"))
  } else if (data_type == "raw_tracker") {
    return(c("participant", "condition", "trialNum"))
  } else {
    return(categoriesExtraInputs)
  }
}

# Use create_dynamic_category_observer for group selection
create_dynamic_category_observer(
  data_reactive = currentData,
  input_id = "group",
  category_choices = get_category_choices(input$dataType),
  default_selection = "participant",
  multiple = FALSE,
  input = input
)

# Use create_dynamic_category_observer for split selection
create_dynamic_category_observer(
  data_reactive = currentData,
  input_id = "split",
  category_choices = c("None", get_category_choices(input$dataType)),
  default_selection = "None",
  multiple = FALSE,
  input = input
)

# Create button observers for all cacheable data types
for (data_type in names(cacheable_data_types)) {
  config <- cacheable_data_types[[data_type]]
  button_id <- config$button_id
  
  # Create observer for this data type's update button
  observeEvent(input[[button_id]], {
    # Flag that data should be (re)loaded
    cache_managers[[data_type]]$request_data()
  }, ignoreNULL = TRUE)
}

# Create status displays for all cacheable data types
for (data_type in names(cacheable_data_types)) {
  config <- cacheable_data_types[[data_type]]
  status_id <- config$status_id
  display_name <- config$display_name
  
  # Create status output for this data type
  output[[status_id]] <- renderText({
    if (input$dataType == data_type) {
      # Get current cached data
      data <- get_cached_data_local(data_type)
      if (nrow(data) > 0) {
        # Build status message with data type specific info
        status_msg <- sprintf(
          "Ready: %d participants, %d trials, %d samples",
          length(unique(data$participant)),
          length(unique(data$trialNum)),
          nrow(data)
        )
        
        # Add data type specific info
        if (data_type == "raw_tracker" && !is.null(input$rawTracker)) {
          status_msg <- paste0(status_msg, sprintf(" (tracker: %s)", input$rawTracker))
        }
        
        return(status_msg)
      } else {
        return(sprintf("No %s loaded. Click 'Update %s' to load %s for the selected participants/trials.", 
                      tolower(display_name), display_name, tolower(display_name)))
      }
    } else {
      return("")
    }
  })
}

plotCount <- reactive({
  colName <- as.character(input$split)
  if (colName == "None" || colName == "") {
    return(1)
  }
  data <- currentData()
  if (nrow(data) == 0 || !colName %in% colnames(data)) {
    return(1)
  }
  return(length(unique(data[[colName]])))
})

plotHeight <- reactive({
  if (input$split == "None") {
    return(input$plotheight)
  } else {
    return(input$plotheight * plotCount())
  }
})

output$hist <- renderSVG({
  reactive({
    page_logger("DEBUG", "=== SVG histogram render triggered ===")
    page_logger("DEBUG", "enableHistograms:", input$enableHistograms)
    
    # Check if histogram plotting is enabled
    if (!input$enableHistograms) {
      page_logger("DEBUG", "Histogram plotting disabled, returning placeholder")
      return(ggplot() +
        annotate("text",
          x = 0.5, y = 0.5,
          label = "Enable histogram plotting using the checkbox above",
          hjust = 0.5, vjust = 0.5, size = 4, color = "blue"
        ) +
        xlim(0, 1) +
        ylim(0, 1) +
        theme_void() +
        ggtitle("Histogram Plotting Disabled"))
    }

    # Use current data source
    page_logger("DEBUG", "Getting current data for histogram")
    data <- currentData()
    page_logger("DEBUG", "Data for histogram:", nrow(data), "rows")

    # Check if we have data
    if (nrow(data) == 0) {
      page_logger("DEBUG", "No data available for histogram")
      # Create empty plot with message
      if (input$dataType %in% names(cacheable_data_types)) {
        config <- cacheable_data_types[[input$dataType]]
        message <- sprintf("No %s available. Please check your filters and ensure participants/trials are selected.", 
                          tolower(config$display_name))
      } else {
        message <- "No data available for the selected filters and data type"
      }
      ggplot() +
        annotate("text",
          x = 0.5, y = 0.5,
          label = message,
          hjust = 0.5, vjust = 0.5, size = 4, color = "red"
        ) +
        xlim(0, 1) +
        ylim(0, 1) +
        theme_void() +
        ggtitle("No Data Available")
    } else {
      # Create histogram with available data
      page_logger("DEBUG", "Creating histogram with parameters:")
      page_logger("DEBUG", "  - group:", input$group)
      page_logger("DEBUG", "  - split:", input$split)
      page_logger("DEBUG", "  - plot variable:", input$plot)
      page_logger("DEBUG", "  - bin width:", input$bin)
      page_logger("DEBUG", "  - position:", input$position)
      page_logger("DEBUG", "  - baseSize:", input$baseSize)
      
      # When using summarized data, pass the same data as both parameters
      mu_data <- if (input$dataType == "summarized") data else get_mu_dyn_long()
      page_logger("DEBUG", "mu_data for histogram:", nrow(mu_data), "rows")
      
      page_logger("DEBUG", "About to call make_histogram...")
      tryCatch({
        result <- make_histogram(data, mu_data, FALSE, input$group, input$split, input$plot, input$bin, input$position, baseSize = input$baseSize)
        page_logger("DEBUG", "make_histogram completed successfully")
        return(result)
      }, error = function(e) {
        page_logger("ERROR", "Error in make_histogram:", e$message)
        return(ggplot() +
          annotate("text",
            x = 0.5, y = 0.5,
            label = paste("Error creating histogram:", e$message),
            hjust = 0.5, vjust = 0.5, size = 4, color = "red"
          ) +
          xlim(0, 1) +
          ylim(0, 1) +
          theme_void() +
          ggtitle("Histogram Error"))
      })
    }
  })
})

# Interactive histogram (Plotly)
output$hist_plotly <- renderPlotly({
  page_logger("DEBUG", "=== Plotly histogram render triggered ===")
  page_logger("DEBUG", "enableHistograms:", input$enableHistograms)
  
  # Check if histogram plotting is enabled
  if (!input$enableHistograms) {
    page_logger("DEBUG", "Histogram plotting disabled, returning placeholder")
    p <- ggplot() +
      annotate("text",
        x = 0.5, y = 0.5,
        label = "Enable histogram plotting using the checkbox above",
        hjust = 0.5, vjust = 0.5, size = 4, color = "blue"
      ) +
      xlim(0, 1) +
      ylim(0, 1) +
      theme_void() +
      ggtitle("Histogram Plotting Disabled")
    return(ggplotly(p, dynamicTicks = TRUE, height = plotHeight()))
  }

  # Use current data source
  page_logger("DEBUG", "Getting current data for Plotly histogram")
  data <- currentData()
  page_logger("DEBUG", "Data for Plotly histogram:", nrow(data), "rows")

  # Check if we have data
  if (nrow(data) == 0) {
    page_logger("DEBUG", "No data available for Plotly histogram")
    if (input$dataType %in% names(cacheable_data_types)) {
      config <- cacheable_data_types[[input$dataType]]
      message <- sprintf("No %s available. Please check your filters and ensure participants/trials are selected.", 
                        tolower(config$display_name))
    } else {
      message <- "No data available for the selected filters and data type"
    }
    p <- ggplot() +
      annotate("text",
        x = 0.5, y = 0.5,
        label = message,
        hjust = 0.5, vjust = 0.5, size = 4, color = "red"
      ) +
      xlim(0, 1) +
      ylim(0, 1) +
      theme_void() +
      ggtitle("No Data Available")
    return(ggplotly(p, dynamicTicks = TRUE, height = plotHeight()))
  }

  # Create histogram with available data and convert to Plotly
  page_logger("DEBUG", "Creating Plotly histogram with parameters:")
  page_logger("DEBUG", "  - group:", input$group)
  page_logger("DEBUG", "  - split:", input$split)
  page_logger("DEBUG", "  - plot variable:", input$plot)
  page_logger("DEBUG", "  - bin width:", input$bin)
  page_logger("DEBUG", "  - position:", input$position)
  page_logger("DEBUG", "  - baseSize:", input$baseSize)
  
  # When using summarized data, pass the same data as both parameters
  mu_data <- if (input$dataType == "summarized") data else get_mu_dyn_long()
  page_logger("DEBUG", "mu_data for Plotly histogram:", nrow(mu_data), "rows")
  
  page_logger("DEBUG", "About to call make_histogram for Plotly...")
  tryCatch({
    p <- make_histogram(data, mu_data, FALSE, input$group, input$split, input$plot, input$bin, input$position, baseSize = input$baseSize)
    page_logger("DEBUG", "make_histogram completed, converting to Plotly...")
    
    plotly_result <- ggplotly(p, tooltip = "all", dynamicTicks = TRUE, height = plotHeight())
    page_logger("DEBUG", "Plotly conversion completed successfully")
    return(plotly_result)
  }, error = function(e) {
    page_logger("ERROR", "Error in Plotly histogram:", e$message)
    error_p <- ggplot() +
      annotate("text",
        x = 0.5, y = 0.5,
        label = paste("Error creating Plotly histogram:", e$message),
        hjust = 0.5, vjust = 0.5, size = 4, color = "red"
      ) +
      xlim(0, 1) +
      ylim(0, 1) +
      theme_void() +
      ggtitle("Plotly Histogram Error")
    return(ggplotly(error_p, dynamicTicks = TRUE, height = plotHeight()))
  })
})

# Add mean tables
output$splitMeanTable <- renderTable({
  # Only render when histograms are enabled
  if (!input$enableHistograms) {
    return(NULL)
  }

  req(input$plot, input$split)
  data <- currentData()
  if (nrow(data) == 0) {
    return(NULL)
  }

  plotVar <- input$plot
  splitVar <- input$split
  if (splitVar != "None" && splitVar %in% colnames(data)) {
    aggregate(data[[plotVar]], by = list(data[[splitVar]]), FUN = mean, na.rm = TRUE)
  }
})

output$overallMeanTable <- renderTable({
  # Only render when histograms are enabled
  if (!input$enableHistograms) {
    return(NULL)
  }

  req(input$plot)
  data <- currentData()
  if (nrow(data) == 0) {
    return(NULL)
  }

  plotVar <- input$plot
  if (plotVar %in% colnames(data)) {
    overallMean <- mean(data[[plotVar]], na.rm = TRUE)
    overallSD <- sd(data[[plotVar]], na.rm = TRUE)
    data.frame(Statistic = c("Mean", "SD"), Value = c(overallMean, overallSD))
  }
})
```

