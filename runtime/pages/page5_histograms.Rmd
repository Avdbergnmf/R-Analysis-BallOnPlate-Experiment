### Options

```{r}
# Data type selection
selectizeInput("dataType", "Data Type",
  choices = c("Summarized Data" = "summarized", "Gait Data" = "gait", "Simulation Data" = "simulation", "Raw Tracker Data" = "raw_tracker"),
  selected = "gait", multiple = FALSE
)

# Status display for simulation data
conditionalPanel(
  condition = "input.dataType == 'simulation'",
  div(
    div(id = "simulationStatus", style = "margin-top: 5px; font-size: 12px; color: #666;"),
    div(
      style = "margin-top: 5px; font-size: 11px; color: #888;",
      "Note: Simulation data is loaded automatically from hazard_samples_with_preds.rds."
    )
  )
)

# Tracker selection and controls for raw tracker data
conditionalPanel(
  condition = "input.dataType == 'raw_tracker'",
  div(
    selectizeInput("rawTracker", "Tracker Type",
      choices = trackers, selected = trackers[2], multiple = FALSE
    ),
    actionButton("rawTrackerUpdateData", "Update Raw Tracker Data",
      class = "btn-primary", style = "margin-bottom: 10px;"
    ),
    div(id = "rawTrackerStatus", style = "margin-top: 5px; font-size: 12px; color: #666;"),
    div(
      style = "margin-top: 5px; font-size: 11px; color: #888;",
      "Note: Click 'Update Raw Tracker Data' to load and cache raw tracker data."
    )
  )
)

selectizeInput("plot", "Plot",
  choices = NULL, selected = NULL, multiple = FALSE
)
selectizeInput("group", "Group by",
  choices = NULL, selected = NULL, multiple = FALSE
)
selectizeInput("position", "Bar positions",
  choices = c("stack", "identity", "dodge"), selected = "identity", multiple = FALSE
)
selectizeInput("split", "Split by",
  choices = NULL, selected = NULL, multiple = FALSE
)
# checkboxInput("means", "Show means",
#  value = TRUE
# )

numericInput("bin", "Bin width",
  min = 0.001, max = 0.5, value = 0.01, step = 0.01
)

checkboxInput("enableHistograms", "Enable histogram plotting",
  value = FALSE
)

checkboxInput("interactiveHist", "Interactive histograms (hover tooltips)",
  value = FALSE
)

checkboxInput("disableSizeCheck", "Disable dataset size check (allow large datasets)",
  value = FALSE
)

# Downsampling control for large datasets
numericInput("downsampleFactor", "Downsampling factor (1=no downsampling, 10=every 10th row)",
  min = 1, max = 100, value = 10, step = 1
)
# Additional checkbox for summarizing across conditions
conditionalPanel(
  condition = "input.dataType == 'summarized'",
  checkboxInput("summarizeAcrossConditions", "Also summarize across conditions (means per participant only)",
    value = FALSE
  )
)

# Show simulation-specific filter only when simulation data type is selected
conditionalPanel(
  condition = "input.dataType == 'simulation'",
  checkboxInput(
    "sim_only_on_plate",
    "Only samples when ball is on the plate",
    value = TRUE
  )
)
```

Column
--------------------------------------------

### Histograms  {data-height=1500}
Create histograms of the step results of the selected data.
```{r}
tagList(
  conditionalPanel(condition = "!input.interactiveHist", imageOutput("hist")),
  conditionalPanel(condition = "input.interactiveHist", plotlyOutput("hist_plotly"))
)
```

### Mean values


```{r}
tableOutput("splitMeanTable")
tableOutput("overallMeanTable")
```



```{r, context="server"}
# Create logger for this page
page_logger <- create_module_logger("PAGE5-HISTOGRAMS")

# Define cacheable data types and their configurations
cacheable_data_types <- list(
  "raw_tracker" = list(
    button_id = "rawTrackerUpdateData",
    status_id = "rawTrackerStatus",
    display_name = "Raw Tracker Data"
  )
)

# Create cache managers and reactive data for all cacheable data types
cache_managers <- list()
cached_data_reactive <- list()

for (data_type in names(cacheable_data_types)) {
  # Create cache manager
  cache_managers[[data_type]] <- create_shiny_cache_manager(data_type, use_parallel = FALSE)

  # Create cached data reactive
  cached_data_reactive[[data_type]] <- create_shiny_cached_data_reactive(
    cache_manager = cache_managers[[data_type]],
    data_type = data_type
  )
}

# Helper function to get cached data for a data type with fast cache lookup
get_cached_data_local <- function(data_type) {
  if (data_type %in% names(cache_managers)) {
    # Try fast cache first
    page_logger("DEBUG", "Trying fast cache lookup for", data_type)

    # Get current filters for fast cache lookup
    current_filters <- get_universal_filters()
    if (!is.null(current_filters)) {
      # Get downsampling factor from user input
      downsample_factor <- if (!is.null(input$downsampleFactor)) input$downsampleFactor else 1

      # Try fast cache lookup
      fast_data <- cache_managers[[data_type]]$get_fast_cache(
        participants = current_filters$participants,
        trials = current_filters$trials,
        condition_filter = current_filters$condition,
        downsample_factor = downsample_factor
      )

      if (!is.null(fast_data)) {
        page_logger("DEBUG", "Fast cache hit! Returning", nrow(fast_data), "rows")
        return(fast_data)
      } else {
        page_logger("DEBUG", "Fast cache miss - falling back to reactive")
      }
    }

    # Fallback to reactive if fast cache miss
    if (data_type %in% names(cached_data_reactive)) {
      page_logger("DEBUG", "Using reactive data for", data_type)
      return(cached_data_reactive[[data_type]]())
    }
  }

  page_logger("DEBUG", "No data available for", data_type)
  return(data.frame())
}

# Helper function to apply data-specific filters
apply_data_filters <- function(data, data_type) {
  if (data_type == "simulation" && nrow(data) > 0) {
    # Optionally filter to only samples where the ball is on the plate
    if (!is.null(input$sim_only_on_plate) && input$sim_only_on_plate &&
      ("simulating" %in% colnames(data))) {
      data <- data[data$simulating == TRUE, , drop = FALSE]
    }
  }
  return(data)
}

# Helper function to get empty data frame structure for a data type
get_empty_data_structure <- function(data_type) {
  base_structure <- data.frame(
    participant = character(0),
    trialNum = numeric(0),
    condition = character(0)
  )

  if (data_type == "simulation") {
    base_structure$phase <- character(0)
  } else if (data_type == "raw_tracker") {
    base_structure$time <- numeric(0)
  }

  return(base_structure)
}

# Reactive data source based on data type selection
currentData <- reactive({
  page_logger("DEBUG", "currentData reactive triggered")
  page_logger("DEBUG", "dataType:", input$dataType)

  # Early return if histogram plotting is disabled to avoid unnecessary data processing
  if (!input$enableHistograms) {
    page_logger("DEBUG", "Histogram plotting disabled, returning empty data structure")
    return(get_empty_data_structure(input$dataType))
  }

  if (input$dataType == "summarized") {
    # Use summarized data when "Summarized Data" is selected
    page_logger("DEBUG", "Using summarized data")
    tryCatch(
      {
        summarized_data <- get_mu_dyn_long()
        if (is.null(summarized_data) || nrow(summarized_data) == 0) {
          page_logger("WARN", "get_mu_dyn_long returned empty data")
          return(data.frame())
        }
        page_logger("DEBUG", "Summarized data loaded:", nrow(summarized_data), "rows")

        # Apply additional summarization across conditions if requested
        if (input$summarizeAcrossConditions) {
          page_logger("DEBUG", "Applying additional summarization across conditions")
          summarized_data <- gait$summarize_across_conditions(summarized_data)
          page_logger("DEBUG", "After condition summarization:", nrow(summarized_data), "rows")
        }
        return(summarized_data)
      },
      error = function(e) {
        page_logger("ERROR", "Error loading summarized data:", e$message)
        page_logger("ERROR", "This usually means required data objects (allGaitParams, allQResults, etc.) are not available")
        return(data.frame())
      }
    )
  } else if (input$dataType == "simulation") {
    # Load hazard samples with predictions directly
    page_logger("DEBUG", "Loading simulation data from hazard_samples_with_preds.rds")
    tryCatch(
      {
        # Get the path from initialization
        hazard_file <- file.path(dataExtraFolder, "hazard_samples_with_preds.rds")
        page_logger("DEBUG", "Loading from:", hazard_file)

        if (file.exists(hazard_file)) {
          data <- readRDS(hazard_file)
          page_logger("DEBUG", "Simulation data loaded:", nrow(data), "rows")

          # Apply universal filters (participants, trials, conditions)
          current_filters <- get_universal_filters()
          if (!is.null(current_filters)) {
            page_logger("DEBUG", "Applying universal filters to simulation data")
            page_logger("DEBUG", "Filter participants:", paste(current_filters$participants, collapse = ", "))
            page_logger("DEBUG", "Filter trials:", paste(current_filters$trials, collapse = ", "))
            page_logger("DEBUG", "Filter conditions:", if (is.null(current_filters$condition)) "NULL" else paste(current_filters$condition, collapse = ", "))

            # Filter by participants
            if (length(current_filters$participants) > 0) {
              data <- data[data$participant %in% current_filters$participants, , drop = FALSE]
              page_logger("DEBUG", "After participant filtering:", nrow(data), "rows")
            }

            # Filter by trials (check both trialNum and trial columns)
            if (length(current_filters$trials) > 0) {
              if ("trialNum" %in% colnames(data)) {
                data <- data[data$trialNum %in% current_filters$trials, , drop = FALSE]
                page_logger("DEBUG", "After trial filtering (trialNum):", nrow(data), "rows")
              } else if ("trial" %in% colnames(data)) {
                data <- data[data$trial %in% current_filters$trials, , drop = FALSE]
                page_logger("DEBUG", "After trial filtering (trial):", nrow(data), "rows")
              } else {
                page_logger("WARN", "No trial column found in simulation data")
              }
            }

            # Filter by conditions
            if (!is.null(current_filters$condition) && length(current_filters$condition) > 0) {
              data <- data[data$condition %in% current_filters$condition, , drop = FALSE]
              page_logger("DEBUG", "After condition filtering:", nrow(data), "rows")
            }
          } else {
            page_logger("WARN", "No universal filters available, using all simulation data")
          }

          # Apply data-specific filters (e.g., sim_only_on_plate)
          data <- apply_data_filters(data, input$dataType)
          page_logger("DEBUG", "After data-specific filtering:", nrow(data), "rows")
          return(data)
        } else {
          page_logger("ERROR", "Hazard samples file not found:", hazard_file)
          return(data.frame())
        }
      },
      error = function(e) {
        page_logger("ERROR", "Error loading simulation data:", e$message)
        return(data.frame())
      }
    )
  } else if (input$dataType == "raw_tracker") {
    # Use cached data for raw tracker
    page_logger("DEBUG", "Using cached data for type:", input$dataType)
    data <- get_cached_data_local(input$dataType)
    page_logger("DEBUG", "Cached data loaded:", nrow(data), "rows")

    if (nrow(data) > 0) {
      # Apply data-specific filters
      page_logger("DEBUG", "Applying data-specific filters")
      data <- apply_data_filters(data, input$dataType)
      page_logger("DEBUG", "After filtering:", nrow(data), "rows")
      return(data)
    }

    # Return empty data frame with expected structure if no data available
    page_logger("DEBUG", "No cached data available, returning empty structure")
    return(get_empty_data_structure(input$dataType))
  } else {
    # Use regular gait data for non-cacheable types
    page_logger("DEBUG", "Using regular gait data")
    gait_data <- filteredParams()
    page_logger("DEBUG", "Gait data loaded:", nrow(gait_data), "rows")
    return(gait_data)
  }
})

# Custom observer for variable selection that handles both gait and simulation data
observe({
  data <- currentData()

  if (is.null(data) || nrow(data) == 0) {
    # updateSelectizeInput(session, "plot", choices = character(0), selected = NULL)
    return()
  }

  # Get all column names from the data
  available_vars <- names(data)

  # Get current selection
  current_selection <- isolate(input$plot)

  # Update the input
  update_selectize_smart(
    session, "plot", available_vars, current_selection
  )
})

# Helper function to get category choices for a data type
get_category_choices <- function(data_type) {
  if (data_type == "simulation") {
    return(c("participant", "condition", "trialNum", "phase", "arcDeg"))
  } else if (data_type == "raw_tracker") {
    return(c("participant", "condition", "trialNum"))
  } else {
    return(categoriesExtraInputs)
  }
}

# Use create_dynamic_category_observer for group selection
create_dynamic_category_observer(
  data_reactive = currentData,
  input_id = "group",
  category_choices = get_category_choices(input$dataType),
  default_selection = "participant",
  multiple = FALSE,
  input = input
)

# Use create_dynamic_category_observer for split selection
create_dynamic_category_observer(
  data_reactive = currentData,
  input_id = "split",
  category_choices = c("None", get_category_choices(input$dataType)),
  default_selection = "None",
  multiple = FALSE,
  input = input
)

# Create button observers for all cacheable data types
for (data_type in names(cacheable_data_types)) {
  config <- cacheable_data_types[[data_type]]
  button_id <- config$button_id

  # Create observer for this data type's update button
  observeEvent(input[[button_id]],
    {
      # Flag that data should be (re)loaded
      cache_managers[[data_type]]$request_data()
    },
    ignoreNULL = TRUE
  )
}

# Simple status display for simulation data
output$simulationStatus <- renderText({
  if (input$dataType == "simulation") {
    data <- currentData()
    if (nrow(data) > 0) {
      # Handle different column names for trials
      trial_col <- if ("trialNum" %in% colnames(data)) "trialNum" else "trial"
      return(sprintf(
        "Ready: %d participants, %d trials, %d samples",
        length(unique(data$participant)),
        length(unique(data[[trial_col]])),
        nrow(data)
      ))
    } else {
      return("No simulation data available. Please check your filters and ensure participants/trials are selected.")
    }
  } else {
    return("")
  }
})

# Create status displays for all cacheable data types
for (data_type in names(cacheable_data_types)) {
  config <- cacheable_data_types[[data_type]]
  status_id <- config$status_id
  display_name <- config$display_name

  # Create status output for this data type
  output[[status_id]] <- renderText({
    if (input$dataType == data_type) {
      # Get current cached data
      data <- get_cached_data_local(data_type)
      if (nrow(data) > 0) {
        # Build status message with data type specific info
        status_msg <- sprintf(
          "Ready: %d participants, %d trials, %d samples",
          length(unique(data$participant)),
          length(unique(data$trialNum)),
          nrow(data)
        )

        # Add data type specific info
        if (data_type == "raw_tracker" && !is.null(input$rawTracker)) {
          status_msg <- paste0(status_msg, sprintf(" (tracker: %s)", input$rawTracker))
        }

        return(status_msg)
      } else {
        return(sprintf(
          "No %s loaded. Click 'Update %s' to load %s for the selected participants/trials.",
          tolower(display_name), display_name, tolower(display_name)
        ))
      }
    } else {
      return("")
    }
  })
}

plotCount <- reactive({
  colName <- as.character(input$split)
  if (colName == "None" || colName == "") {
    return(1)
  }
  data <- currentData()
  if (nrow(data) == 0 || !colName %in% colnames(data)) {
    return(1)
  }
  return(length(unique(data[[colName]])))
})

plotHeight <- reactive({
  if (input$split == "None") {
    return(input$plotheight)
  } else {
    return(input$plotheight * plotCount())
  }
})

output$hist <- renderSVG({
  reactive({
    page_logger("DEBUG", "=== SVG histogram render triggered ===")
    page_logger("DEBUG", "enableHistograms:", input$enableHistograms)

    # Check if histogram plotting is enabled
    if (!input$enableHistograms) {
      page_logger("DEBUG", "Histogram plotting disabled, returning placeholder")
      return(ggplot() +
        annotate("text",
          x = 0.5, y = 0.5,
          label = "Enable histogram plotting using the checkbox above",
          hjust = 0.5, vjust = 0.5, size = 4, color = "blue"
        ) +
        xlim(0, 1) +
        ylim(0, 1) +
        theme_void() +
        ggtitle("Histogram Plotting Disabled"))
    }

    # Use current data source
    page_logger("DEBUG", "Getting current data for histogram")
    data <- currentData()
    page_logger("DEBUG", "Data for histogram:", nrow(data), "rows")

    # Check if we have data
    if (nrow(data) == 0) {
      page_logger("DEBUG", "No data available for histogram")
      # Create empty plot with message
      if (input$dataType %in% names(cacheable_data_types)) {
        config <- cacheable_data_types[[input$dataType]]
        message <- sprintf(
          "No %s available. Please check your filters and ensure participants/trials are selected.",
          tolower(config$display_name)
        )
      } else {
        message <- "No data available for the selected filters and data type"
      }
      ggplot() +
        annotate("text",
          x = 0.5, y = 0.5,
          label = message,
          hjust = 0.5, vjust = 0.5, size = 4, color = "red"
        ) +
        xlim(0, 1) +
        ylim(0, 1) +
        theme_void() +
        ggtitle("No Data Available")
    } else {
      # Create histogram with available data
      page_logger("DEBUG", "Creating histogram with parameters:")
      page_logger("DEBUG", "  - group:", input$group)
      page_logger("DEBUG", "  - split:", input$split)
      page_logger("DEBUG", "  - plot variable:", input$plot)
      page_logger("DEBUG", "  - bin width:", input$bin)
      page_logger("DEBUG", "  - position:", input$position)
      page_logger("DEBUG", "  - baseSize:", input$baseSize)

      # When using summarized data, pass the same data as both parameters
      mu_data <- if (input$dataType == "summarized") data else get_mu_dyn_long()
      page_logger("DEBUG", "mu_data for histogram:", nrow(mu_data), "rows")

      page_logger("DEBUG", "About to call make_histogram...")
      tryCatch(
        {
          result <- plotting$make_histogram(data, mu_data, FALSE, input$group, input$split, input$plot, input$bin, input$position, baseSize = input$baseSize, disable_size_check = input$disableSizeCheck)
          page_logger("DEBUG", "make_histogram completed successfully")
          return(result)
        },
        error = function(e) {
          page_logger("ERROR", "Error in make_histogram:", e$message)
          return(ggplot() +
            annotate("text",
              x = 0.5, y = 0.5,
              label = paste("Error creating histogram:", e$message),
              hjust = 0.5, vjust = 0.5, size = 4, color = "red"
            ) +
            xlim(0, 1) +
            ylim(0, 1) +
            theme_void() +
            ggtitle("Histogram Error"))
        }
      )
    }
  })
})

# Interactive histogram (Plotly)
output$hist_plotly <- renderPlotly({
  page_logger("DEBUG", "=== Plotly histogram render triggered ===")
  page_logger("DEBUG", "enableHistograms:", input$enableHistograms)

  # Check if histogram plotting is enabled
  if (!input$enableHistograms) {
    page_logger("DEBUG", "Histogram plotting disabled, returning placeholder")
    p <- ggplot() +
      annotate("text",
        x = 0.5, y = 0.5,
        label = "Enable histogram plotting using the checkbox above",
        hjust = 0.5, vjust = 0.5, size = 4, color = "blue"
      ) +
      xlim(0, 1) +
      ylim(0, 1) +
      theme_void() +
      ggtitle("Histogram Plotting Disabled")
    return(ggplotly(p, dynamicTicks = TRUE, height = plotHeight()))
  }

  # Use current data source
  page_logger("DEBUG", "Getting current data for Plotly histogram")
  data <- currentData()
  page_logger("DEBUG", "Data for Plotly histogram:", nrow(data), "rows")

  # Check if we have data
  if (nrow(data) == 0) {
    page_logger("DEBUG", "No data available for Plotly histogram")
    if (input$dataType %in% names(cacheable_data_types)) {
      config <- cacheable_data_types[[input$dataType]]
      message <- sprintf(
        "No %s available. Please check your filters and ensure participants/trials are selected.",
        tolower(config$display_name)
      )
    } else {
      message <- "No data available for the selected filters and data type"
    }
    p <- ggplot() +
      annotate("text",
        x = 0.5, y = 0.5,
        label = message,
        hjust = 0.5, vjust = 0.5, size = 4, color = "red"
      ) +
      xlim(0, 1) +
      ylim(0, 1) +
      theme_void() +
      ggtitle("No Data Available")
    return(ggplotly(p, dynamicTicks = TRUE, height = plotHeight()))
  }

  # Create histogram with available data and convert to Plotly
  page_logger("DEBUG", "Creating Plotly histogram with parameters:")
  page_logger("DEBUG", "  - group:", input$group)
  page_logger("DEBUG", "  - split:", input$split)
  page_logger("DEBUG", "  - plot variable:", input$plot)
  page_logger("DEBUG", "  - bin width:", input$bin)
  page_logger("DEBUG", "  - position:", input$position)
  page_logger("DEBUG", "  - baseSize:", input$baseSize)

  # When using summarized data, pass the same data as both parameters
  mu_data <- if (input$dataType == "summarized") data else get_mu_dyn_long()
  page_logger("DEBUG", "mu_data for Plotly histogram:", nrow(mu_data), "rows")

  page_logger("DEBUG", "About to call make_histogram for Plotly...")
  tryCatch(
    {
      p <- plotting$make_histogram(data, mu_data, FALSE, input$group, input$split, input$plot, input$bin, input$position, baseSize = input$baseSize, disable_size_check = input$disableSizeCheck)
      page_logger("DEBUG", "make_histogram completed, converting to Plotly...")

      plotly_result <- ggplotly(p, tooltip = "all", dynamicTicks = TRUE, height = plotHeight())
      page_logger("DEBUG", "Plotly conversion completed successfully")
      return(plotly_result)
    },
    error = function(e) {
      page_logger("ERROR", "Error in Plotly histogram:", e$message)
      error_p <- ggplot() +
        annotate("text",
          x = 0.5, y = 0.5,
          label = paste("Error creating Plotly histogram:", e$message),
          hjust = 0.5, vjust = 0.5, size = 4, color = "red"
        ) +
        xlim(0, 1) +
        ylim(0, 1) +
        theme_void() +
        ggtitle("Plotly Histogram Error")
      return(ggplotly(error_p, dynamicTicks = TRUE, height = plotHeight()))
    }
  )
})

# Add mean tables
output$splitMeanTable <- renderTable({
  # Only render when histograms are enabled
  if (!input$enableHistograms) {
    return(NULL)
  }

  req(input$plot, input$split)
  data <- currentData()
  if (nrow(data) == 0) {
    return(NULL)
  }

  plotVar <- input$plot
  splitVar <- input$split
  if (splitVar != "None" && splitVar %in% colnames(data)) {
    aggregate(data[[plotVar]], by = list(data[[splitVar]]), FUN = mean, na.rm = TRUE)
  }
})

output$overallMeanTable <- renderTable({
  # Only render when histograms are enabled
  if (!input$enableHistograms) {
    return(NULL)
  }

  req(input$plot)
  data <- currentData()
  if (nrow(data) == 0) {
    return(NULL)
  }

  plotVar <- input$plot
  if (plotVar %in% colnames(data)) {
    overallMean <- mean(data[[plotVar]], na.rm = TRUE)
    overallSD <- sd(data[[plotVar]], na.rm = TRUE)
    data.frame(Statistic = c("Mean", "SD"), Value = c(overallMean, overallSD))
  }
})
```

